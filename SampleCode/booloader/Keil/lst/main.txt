; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\main.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\Library\StdDriver\inc -I..\..\Template -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\main.crf ..\main.c]
                          THUMB

                          AREA ||i.Check_if_FW_update_TimeOut||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                  Check_if_FW_update_TimeOut PROC
;;;420    
;;;421    void Check_if_FW_update_TimeOut(void)
000000  b510              PUSH     {r4,lr}
;;;422    {
;;;423        if (SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk)
000002  f04f20e0          MOV      r0,#0xe000e000
000006  6900              LDR      r0,[r0,#0x10]
000008  03c0              LSLS     r0,r0,#15
00000a  d50b              BPL      |L1.36|
;;;424        {
;;;425    	    printf("boot loader : %s\r\n", __FUNCTION__);
00000c  4906              LDR      r1,|L1.40|
00000e  a007              ADR      r0,|L1.44|
000010  f7fffffe          BL       __2printf
                  |L1.20|
;;;426    	    while(IsDebugFifoEmpty() == 0);
000014  f7fffffe          BL       IsDebugFifoEmpty
000018  2800              CMP      r0,#0
00001a  d0fb              BEQ      |L1.20|
;;;427    	
;;;428            Jump_To_Application();
00001c  e8bd4010          POP      {r4,lr}
000020  f7ffbffe          B.W      Jump_To_Application
                  |L1.36|
;;;429        }
;;;430    
;;;431    }
000024  bd10              POP      {r4,pc}
;;;432    
                          ENDP

000026  0000              DCW      0x0000
                  |L1.40|
                          DCD      ||.constdata||+0x3f
                  |L1.44|
00002c  626f6f74          DCB      "boot loader : %s\r\n",0
000030  206c6f61
000034  64657220
000038  3a202573
00003c  0d0a00  
00003f  00                DCB      0

                          AREA ||i.Custom_Init||, CODE, READONLY, ALIGN=2

                  Custom_Init PROC
;;;581    
;;;582    void Custom_Init(void)
000000  b510              PUSH     {r4,lr}
;;;583    {	
;;;584    	//EVM LED
;;;585    	GPIO_SetMode(PH,BIT0,GPIO_MODE_OUTPUT);
000002  4c10              LDR      r4,|L2.68|
000004  2201              MOVS     r2,#1
000006  4611              MOV      r1,r2
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       GPIO_SetMode
;;;586    	GPIO_SetMode(PH,BIT1,GPIO_MODE_OUTPUT);
00000e  2201              MOVS     r2,#1
000010  2102              MOVS     r1,#2
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       GPIO_SetMode
;;;587    	GPIO_SetMode(PH,BIT2,GPIO_MODE_OUTPUT);
000018  2201              MOVS     r2,#1
00001a  2104              MOVS     r1,#4
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       GPIO_SetMode
;;;588    
;;;589    	// EVM M483 LED
;;;590    	GPIO_SetMode(PH,BIT4,GPIO_MODE_OUTPUT);
000022  2201              MOVS     r2,#1
000024  2110              MOVS     r1,#0x10
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       GPIO_SetMode
;;;591    	GPIO_SetMode(PH,BIT5,GPIO_MODE_OUTPUT);
00002c  2201              MOVS     r2,#1
00002e  2120              MOVS     r1,#0x20
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       GPIO_SetMode
;;;592    	GPIO_SetMode(PH,BIT6,GPIO_MODE_OUTPUT);	
000036  4620              MOV      r0,r4
000038  2201              MOVS     r2,#1
00003a  e8bd4010          POP      {r4,lr}
00003e  2140              MOVS     r1,#0x40
000040  f7ffbffe          B.W      GPIO_SetMode
;;;593    }
;;;594    
                          ENDP

                  |L2.68|
                          DCD      0x400041c0

                          AREA ||i.FMC_Disable||, CODE, READONLY, ALIGN=1

                  FMC_Disable PROC
;;;241    
;;;242    void FMC_Disable(void)
000000  b510              PUSH     {r4,lr}
;;;243    {
;;;244        FMC_Close();                       /* Disable FMC ISP function */
000002  f7fffffe          BL       FMC_Close
000006  f04f4180          MOV      r1,#0x40000000
00000a  2000              MOVS     r0,#0
00000c  f8c10100          STR      r0,[r1,#0x100]
;;;245    
;;;246        SYS_LockReg();                     /* Lock protected registers */
;;;247    }
000010  bd10              POP      {r4,pc}
;;;248    
                          ENDP


                          AREA ||i.FMC_Enable||, CODE, READONLY, ALIGN=1

                  FMC_Enable PROC
;;;234    
;;;235    void FMC_Enable(void)
000000  b510              PUSH     {r4,lr}
;;;236    {
;;;237        SYS_UnlockReg();                   /* Unlock register lock protect */
000002  f7fffffe          BL       SYS_UnlockReg
;;;238    
;;;239        FMC_Open();                        /* Enable FMC ISP function */
000006  e8bd4010          POP      {r4,lr}
00000a  f7ffbffe          B.W      FMC_Open
;;;240    }
;;;241    
                          ENDP


                          AREA ||i.GPIO_Init||, CODE, READONLY, ALIGN=2

                  GPIO_Init PROC
;;;450    
;;;451    void GPIO_Init (void)
000000  b510              PUSH     {r4,lr}
;;;452    {
;;;453        GPIO_SetMode(PB, BIT14, GPIO_MODE_OUTPUT);
000002  4c06              LDR      r4,|L5.28|
000004  2201              MOVS     r2,#1
000006  0391              LSLS     r1,r2,#14
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       GPIO_SetMode
;;;454    
;;;455        GPIO_SetMode(PB, BIT15, GPIO_MODE_OUTPUT);	
00000e  4620              MOV      r0,r4
000010  2201              MOVS     r2,#1
000012  e8bd4010          POP      {r4,lr}
000016  03d1              LSLS     r1,r2,#15
000018  f7ffbffe          B.W      GPIO_SetMode
;;;456    }
;;;457    
                          ENDP

                  |L5.28|
                          DCD      0x40004040

                          AREA ||i.Jump_To_Application||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                  Jump_To_Application PROC
;;;380    
;;;381    void Jump_To_Application(void)
000000  b510              PUSH     {r4,lr}
;;;382    {
;;;383        printf("boot loader : %s\r\n", __FUNCTION__);
000002  4911              LDR      r1,|L6.72|
000004  a011              ADR      r0,|L6.76|
000006  f7fffffe          BL       __2printf
                  |L6.10|
;;;384        while(IsDebugFifoEmpty() == 0);
00000a  f7fffffe          BL       IsDebugFifoEmpty
00000e  2800              CMP      r0,#0
000010  d0fb              BEQ      |L6.10|
;;;385    
;;;386    	resetPeripherals();
000012  f7fffffe          BL       resetPeripherals
;;;387    
;;;388    	FMC_Enable();
000016  f7fffffe          BL       FMC_Enable
00001a  4811              LDR      r0,|L6.96|
00001c  222e              MOVS     r2,#0x2e
;;;389        FMC_SetVectorPageAddr(FMC_CUSTOM_APROM_BASE);
00001e  f44f4100          MOV      r1,#0x8000
000022  60c2              STR      r2,[r0,#0xc]
000024  6041              STR      r1,[r0,#4]
000026  2101              MOVS     r1,#1
000028  6101              STR      r1,[r0,#0x10]
                  |L6.42|
00002a  6901              LDR      r1,[r0,#0x10]
00002c  2900              CMP      r1,#0
00002e  d1fc              BNE      |L6.42|
;;;390    
;;;391        /* Reset CPU only to reset to new vector page */
;;;392        SYS_ResetCPU();
000030  f7fffffe          BL       SYS_ResetCPU
;;;393    
;;;394        /* Reset System to reset to new vector page. */
;;;395        //NVIC_SystemReset();
;;;396    
;;;397    	FMC_Disable();
000034  f7fffffe          BL       FMC_Disable
;;;398    
;;;399        while (SYS->PDID) __WFI();
000038  f04f4080          MOV      r0,#0x40000000
00003c  e000              B        |L6.64|
                  |L6.62|
00003e  bf30              WFI      
                  |L6.64|
000040  6801              LDR      r1,[r0,#0]
000042  2900              CMP      r1,#0
000044  d1fb              BNE      |L6.62|
;;;400    
;;;401    }
000046  bd10              POP      {r4,pc}
;;;402    
                          ENDP

                  |L6.72|
                          DCD      ||.constdata||+0x2b
                  |L6.76|
00004c  626f6f74          DCB      "boot loader : %s\r\n",0
000050  206c6f61
000054  64657220
000058  3a202573
00005c  0d0a00  
00005f  00                DCB      0
                  |L6.96|
                          DCD      0x4000c000

                          AREA ||i.Manual_update_FW||, CODE, READONLY, ALIGN=2

                  Manual_update_FW PROC
;;;432    
;;;433    void Manual_update_FW(void)
000000  b510              PUSH     {r4,lr}
;;;434    {
;;;435        uint8_t u8Ch;
;;;436    
;;;437    	printf("boot loader : selection option to manual update firmware or jump to application.\r\n");
000002  480a              LDR      r0,|L7.44|
000004  f7fffffe          BL       __2printf
;;;438    	printf("boot loader >>>>> pre-progammming APP_01 to 0x10000\r\n");
000008  a009              ADR      r0,|L7.48|
00000a  f7fffffe          BL       __2printf
;;;439    	printf("boot loader >>>>> pre-progammming APP_02 to 0x12000\r\n");
00000e  a016              ADR      r0,|L7.104|
000010  f7fffffe          BL       __2printf
;;;440    	
;;;441    	
;;;442    	printf("boot loader : [1] , update APP_01 to 0x8000 ,  (APP_01 store in 0x10000)\r\n");
000014  4822              LDR      r0,|L7.160|
000016  f7fffffe          BL       __2printf
;;;443    	printf("boot loader : [2] , update APP_02 to 0x8000 , (APP_02 store in 0x12000)\r\n");
00001a  4822              LDR      r0,|L7.164|
00001c  f7fffffe          BL       __2printf
;;;444    	
;;;445    	u8Ch = getchar();
000020  e8bd4010          POP      {r4,lr}
000024  4820              LDR      r0,|L7.168|
000026  f7ffbffe          B.W      getc
;;;446    
;;;447    	
;;;448    }
;;;449    
                          ENDP

00002a  0000              DCW      0x0000
                  |L7.44|
                          DCD      ||.conststring||+0x1a0
                  |L7.48|
000030  626f6f74          DCB      "boot loader >>>>> pre-progammming APP_01 to 0x10000\r\n"
000034  206c6f61
000038  64657220
00003c  3e3e3e3e
000040  3e207072
000044  652d7072
000048  6f67616d
00004c  6d6d696e
000050  67204150
000054  505f3031
000058  20746f20
00005c  30783130
000060  3030300d
000064  0a      
000065  00                DCB      0
000066  00                DCB      0
000067  00                DCB      0
                  |L7.104|
000068  626f6f74          DCB      "boot loader >>>>> pre-progammming APP_02 to 0x12000\r\n"
00006c  206c6f61
000070  64657220
000074  3e3e3e3e
000078  3e207072
00007c  652d7072
000080  6f67616d
000084  6d6d696e
000088  67204150
00008c  505f3032
000090  20746f20
000094  30783132
000098  3030300d
00009c  0a      
00009d  00                DCB      0
00009e  00                DCB      0
00009f  00                DCB      0
                  |L7.160|
                          DCD      ||.conststring||+0x1f4
                  |L7.164|
                          DCD      ||.conststring||+0x240
                  |L7.168|
                          DCD      __stdin

                          AREA ||i.NVIC_DisableIRQ||, CODE, READONLY, ALIGN=1

                  NVIC_DisableIRQ PROC
;;;1636    */
;;;1637   __STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
000000  f000021f          AND      r2,r0,#0x1f
;;;1638   {
;;;1639     NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  0940              LSRS     r0,r0,#5
00000a  0080              LSLS     r0,r0,#2
00000c  f10020e0          ADD      r0,r0,#0xe000e000
000010  f8c01180          STR      r1,[r0,#0x180]
;;;1640   }
000014  4770              BX       lr
;;;1641   
                          ENDP


                          AREA ||i.NVIC_EnableIRQ||, CODE, READONLY, ALIGN=1

                  NVIC_EnableIRQ PROC
;;;1625    */
;;;1626   __STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
000000  f000021f          AND      r2,r0,#0x1f
;;;1627   {
;;;1628     NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  0940              LSRS     r0,r0,#5
00000a  0080              LSLS     r0,r0,#2
00000c  f10020e0          ADD      r0,r0,#0xe000e000
000010  f8c01100          STR      r1,[r0,#0x100]
;;;1629   }
000014  4770              BX       lr
;;;1630   
                          ENDP


                          AREA ||i.NVIC_SystemReset||, CODE, READONLY, ALIGN=2

                  NVIC_SystemReset PROC
;;;1789    */
;;;1790   __STATIC_INLINE void NVIC_SystemReset(void)
000000  f3bf8f4f          DSB      
;;;1791   {
;;;1792     __DSB();                                                          /* Ensure all outstanding memory accesses included
;;;1793                                                                          buffered write are completed before reset */
;;;1794     SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
000004  4805              LDR      r0,|L10.28|
000006  6801              LDR      r1,[r0,#0]
000008  4a05              LDR      r2,|L10.32|
00000a  f40161e0          AND      r1,r1,#0x700
00000e  4311              ORRS     r1,r1,r2
000010  6001              STR      r1,[r0,#0]
;;;1795                              (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
;;;1796                               SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
;;;1797     __DSB();                                                          /* Ensure completion of memory access */
000012  f3bf8f4f          DSB      
                  |L10.22|
;;;1798   
;;;1799     for(;;)                                                           /* wait until reset */
;;;1800     {
;;;1801       __NOP();
000016  bf00              NOP      
000018  e7fd              B        |L10.22|
;;;1802     }
;;;1803   }
;;;1804   
                          ENDP

00001a  0000              DCW      0x0000
                  |L10.28|
                          DCD      0xe000ed0c
                  |L10.32|
                          DCD      0x05fa0004

                          AREA ||i.Read_BS||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  Read_BS PROC
;;;333    
;;;334    void Read_BS(void)
000000  b570              PUSH     {r4-r6,lr}
;;;335    {
;;;336    	uint32_t res = 0;
;;;337    
;;;338    
;;;339    	printf("boot loader >>>>> make sure CONFIG set as [APROM with IAP]\r\n");
000002  a01f              ADR      r0,|L11.128|
000004  f7fffffe          BL       __2printf
;;;340    	printf("boot loader >>>>> APP_01 in KEIL linker option R/O base :0x00008000\r\n");
000008  482d              LDR      r0,|L11.192|
00000a  f7fffffe          BL       __2printf
;;;341    	printf("boot loader >>>>> APP_02 in KEIL linker option R/O base :0x00008000\r\n");
00000e  482d              LDR      r0,|L11.196|
000010  f7fffffe          BL       __2printf
;;;342    
;;;343    
;;;344    
;;;345    	res = FMC_GetBootSource();
000014  f7fffffe          BL       FMC_GetBootSource
000018  4602              MOV      r2,r0
;;;346    	printf("boot loader : %s : %d\r\n" , __FUNCTION__ ,res);
00001a  492b              LDR      r1,|L11.200|
00001c  a02b              ADR      r0,|L11.204|
00001e  f7fffffe          BL       __2printf
000022  4c30              LDR      r4,|L11.228|
000024  200b              MOVS     r0,#0xb
000026  60e0              STR      r0,[r4,#0xc]
000028  2000              MOVS     r0,#0
00002a  6060              STR      r0,[r4,#4]
00002c  2501              MOVS     r5,#1
00002e  6125              STR      r5,[r4,#0x10]
                  |L11.48|
000030  6920              LDR      r0,[r4,#0x10]
000032  07c0              LSLS     r0,r0,#31
000034  d1fc              BNE      |L11.48|
000036  68a1              LDR      r1,[r4,#8]
;;;347    
;;;348        res = FMC_ReadCID();
;;;349        printf("boot loader : Company ID ............................ [0x%08X]\r\n", res);
000038  482b              LDR      r0,|L11.232|
00003a  f7fffffe          BL       __2printf
00003e  200c              MOVS     r0,#0xc
000040  60e0              STR      r0,[r4,#0xc]
000042  2004              MOVS     r0,#4
000044  6060              STR      r0,[r4,#4]
000046  6125              STR      r5,[r4,#0x10]
                  |L11.72|
000048  6920              LDR      r0,[r4,#0x10]
00004a  07c0              LSLS     r0,r0,#31
00004c  d1fc              BNE      |L11.72|
00004e  68a1              LDR      r1,[r4,#8]
;;;350    
;;;351        res = FMC_ReadPID();
;;;352        printf("boot loader : Product ID ............................ [0x%08X]\r\n", res);
000050  4826              LDR      r0,|L11.236|
000052  f7fffffe          BL       __2printf
;;;353    
;;;354        /* Read User Configuration */
;;;355        printf("boot loader : User Config 0 ......................... [0x%08X]\r\n", FMC_Read(CONFIG0_ADDR));
000056  f44f1040          MOV      r0,#0x300000
00005a  f7fffffe          BL       FMC_Read
00005e  4601              MOV      r1,r0
000060  4823              LDR      r0,|L11.240|
000062  f7fffffe          BL       __2printf
;;;356        /* Read User Configuration CONFIG1 */
;;;357        printf("boot loader : User Config 1 ......................... [0x%08X]\r\n", FMC_Read(CONFIG1_ADDR));
000066  4823              LDR      r0,|L11.244|
000068  f7fffffe          BL       FMC_Read
00006c  4601              MOV      r1,r0
00006e  4822              LDR      r0,|L11.248|
000070  f7fffffe          BL       __2printf
                  |L11.116|
;;;358    
;;;359        while(IsDebugFifoEmpty() == 0);
000074  f7fffffe          BL       IsDebugFifoEmpty
000078  2800              CMP      r0,#0
00007a  d0fb              BEQ      |L11.116|
;;;360    	
;;;361    }
00007c  bd70              POP      {r4-r6,pc}
;;;362    
                          ENDP

00007e  0000              DCW      0x0000
                  |L11.128|
000080  626f6f74          DCB      "boot loader >>>>> make sure CONFIG set as [APROM with I"
000084  206c6f61
000088  64657220
00008c  3e3e3e3e
000090  3e206d61
000094  6b652073
000098  75726520
00009c  434f4e46
0000a0  49472073
0000a4  65742061
0000a8  73205b41
0000ac  50524f4d
0000b0  20776974
0000b4  682049  
0000b7  41505d0d          DCB      "AP]\r\n",0
0000bb  0a00    
0000bd  00                DCB      0
0000be  00                DCB      0
0000bf  00                DCB      0
                  |L11.192|
                          DCD      ||.conststring||
                  |L11.196|
                          DCD      ||.conststring||+0x48
                  |L11.200|
                          DCD      ||.constdata||
                  |L11.204|
0000cc  626f6f74          DCB      "boot loader : %s : %d\r\n",0
0000d0  206c6f61
0000d4  64657220
0000d8  3a202573
0000dc  203a2025
0000e0  640d0a00
                  |L11.228|
                          DCD      0x4000c000
                  |L11.232|
                          DCD      ||.conststring||+0x90
                  |L11.236|
                          DCD      ||.conststring||+0xd4
                  |L11.240|
                          DCD      ||.conststring||+0x118
                  |L11.244|
                          DCD      0x00300004
                  |L11.248|
                          DCD      ||.conststring||+0x15c

                          AREA ||i.SYS_Init||, CODE, READONLY, ALIGN=2

                  SYS_Init PROC
;;;594    
;;;595    void SYS_Init(void)
000000  b570              PUSH     {r4-r6,lr}
;;;596    {
;;;597        /* Unlock protected registers */
;;;598        SYS_UnlockReg();
000002  f7fffffe          BL       SYS_UnlockReg
;;;599    
;;;600        /* Set XT1_OUT(PF.2) and XT1_IN(PF.3) to input mode */
;;;601        PF->MODE &= ~(GPIO_MODE_MODE2_Msk | GPIO_MODE_MODE3_Msk);
000006  f04f2040          MOV      r0,#0x40004000
00000a  f8d01140          LDR      r1,[r0,#0x140]
00000e  f02101f0          BIC      r1,r1,#0xf0
000012  f8c01140          STR      r1,[r0,#0x140]
;;;602    
;;;603        /* Enable External XTAL (4~24 MHz) */
;;;604        CLK_EnableXtalRC(CLK_PWRCTL_HXTEN_Msk|CLK_PWRCTL_HIRCEN_Msk);
000016  2005              MOVS     r0,#5
000018  f7fffffe          BL       CLK_EnableXtalRC
;;;605    
;;;606        /* Waiting for 12MHz clock ready */
;;;607        CLK_WaitClockReady(CLK_STATUS_HXTSTB_Msk|CLK_STATUS_HIRCSTB_Msk);
00001c  2011              MOVS     r0,#0x11
00001e  f7fffffe          BL       CLK_WaitClockReady
;;;608    
;;;609        CLK_EnableXtalRC(CLK_PWRCTL_LXTEN_Msk|CLK_PWRCTL_LIRCEN_Msk);
000022  200a              MOVS     r0,#0xa
000024  f7fffffe          BL       CLK_EnableXtalRC
;;;610    
;;;611        /* Waiting for 12MHz clock ready */
;;;612        CLK_WaitClockReady(CLK_STATUS_LXTSTB_Msk|CLK_STATUS_LIRCSTB_Msk);
000028  200a              MOVS     r0,#0xa
00002a  f7fffffe          BL       CLK_WaitClockReady
;;;613    
;;;614        /* Set core clock as PLL_CLOCK from PLL */
;;;615        CLK_SetCoreClock(FREQ_192MHZ);
00002e  4819              LDR      r0,|L12.148|
000030  f7fffffe          BL       CLK_SetCoreClock
;;;616        /* Set PCLK0/PCLK1 to HCLK/2 */
;;;617        CLK->PCLKDIV = (CLK_PCLKDIV_APB0DIV_DIV2 | CLK_PCLKDIV_APB1DIV_DIV2);
000034  2011              MOVS     r0,#0x11
000036  0784              LSLS     r4,r0,#30
000038  f8c40234          STR      r0,[r4,#0x234]
;;;618    
;;;619        /* Enable UART clock */
;;;620        CLK_EnableModuleClock(UART0_MODULE);
00003c  4d16              LDR      r5,|L12.152|
00003e  4628              MOV      r0,r5
000040  f7fffffe          BL       CLK_EnableModuleClock
;;;621        /* Select UART clock source from HXT */
;;;622        CLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UART0SEL_HIRC, CLK_CLKDIV0_UART0(1));
000044  2200              MOVS     r2,#0
000046  f04f7140          MOV      r1,#0x3000000
00004a  4628              MOV      r0,r5
00004c  f7fffffe          BL       CLK_SetModuleClock
;;;623    
;;;624        /* Set GPB multi-function pins for UART0 RXD and TXD */
;;;625        SYS->GPB_MFPH &= ~(SYS_GPB_MFPH_PB12MFP_Msk | SYS_GPB_MFPH_PB13MFP_Msk);
000050  6be0              LDR      r0,[r4,#0x3c]
000052  f420007f          BIC      r0,r0,#0xff0000
000056  63e0              STR      r0,[r4,#0x3c]
;;;626        SYS->GPB_MFPH |= (SYS_GPB_MFPH_PB12MFP_UART0_RXD | SYS_GPB_MFPH_PB13MFP_UART0_TXD);
000058  6be0              LDR      r0,[r4,#0x3c]
00005a  f44000cc          ORR      r0,r0,#0x660000
00005e  63e0              STR      r0,[r4,#0x3c]
;;;627    
;;;628        CLK_EnableModuleClock(TMR1_MODULE);
000060  4d0e              LDR      r5,|L12.156|
000062  4628              MOV      r0,r5
000064  f7fffffe          BL       CLK_EnableModuleClock
;;;629        CLK_SetModuleClock(TMR1_MODULE, CLK_CLKSEL1_TMR1SEL_HIRC, 0);
000068  2200              MOVS     r2,#0
00006a  f44f41e0          MOV      r1,#0x7000
00006e  4628              MOV      r0,r5
000070  f7fffffe          BL       CLK_SetModuleClock
;;;630    
;;;631        CLK_EnableModuleClock(RTC_MODULE);
000074  4d0a              LDR      r5,|L12.160|
000076  4628              MOV      r0,r5
000078  f7fffffe          BL       CLK_EnableModuleClock
;;;632        CLK_SetModuleClock(RTC_MODULE, CLK_CLKSEL3_RTCSEL_LXT,  NULL);
00007c  2200              MOVS     r2,#0
00007e  4611              MOV      r1,r2
000080  4628              MOV      r0,r5
000082  f7fffffe          BL       CLK_SetModuleClock
;;;633    
;;;634    	    /* Update System Core Clock */
;;;635        /* User can use SystemCoreClockUpdate() to calculate SystemCoreClock. */
;;;636        SystemCoreClockUpdate();
000086  f7fffffe          BL       SystemCoreClockUpdate
00008a  2000              MOVS     r0,#0
00008c  f8c40100          STR      r0,[r4,#0x100]
;;;637    
;;;638        /* Lock protected registers */
;;;639        SYS_LockReg();
;;;640    }
000090  bd70              POP      {r4-r6,pc}
;;;641    
                          ENDP

000092  0000              DCW      0x0000
                  |L12.148|
                          DCD      0x0b71b000
                  |L12.152|
                          DCD      0x57803d10
                  |L12.156|
                          DCD      0x5ec00003
                  |L12.160|
                          DCD      0x72800001

                          AREA ||i.SYS_UnlockReg||, CODE, READONLY, ALIGN=1

                  SYS_UnlockReg PROC
;;;1585     */
;;;1586   __STATIC_INLINE void SYS_UnlockReg(void)
000000  2159              MOVS     r1,#0x59
;;;1587   {
000002  b510              PUSH     {r4,lr}
;;;1588       do
;;;1589       {
;;;1590           SYS->REGLCTL = 0x59UL;
000004  0788              LSLS     r0,r1,#30
;;;1591           SYS->REGLCTL = 0x16UL;
000006  2216              MOVS     r2,#0x16
;;;1592           SYS->REGLCTL = 0x88UL;
000008  2388              MOVS     r3,#0x88
                  |L13.10|
00000a  f8c01100          STR      r1,[r0,#0x100]        ;1590
00000e  f8c02100          STR      r2,[r0,#0x100]        ;1591
000012  f8c03100          STR      r3,[r0,#0x100]
;;;1593       }
;;;1594       while(SYS->REGLCTL == 0UL);
000016  f8d04100          LDR      r4,[r0,#0x100]
00001a  2c00              CMP      r4,#0
00001c  d0f5              BEQ      |L13.10|
;;;1595   }
00001e  bd10              POP      {r4,pc}
;;;1596   
                          ENDP


                          AREA ||i.TIMER1_Init||, CODE, READONLY, ALIGN=2

                  TIMER1_Init PROC
;;;487    
;;;488    void TIMER1_Init(void)
000000  b510              PUSH     {r4,lr}
;;;489    {
;;;490        TIMER_Open(TIMER1, TIMER_PERIODIC_MODE, 1000);
000002  4c0a              LDR      r4,|L14.44|
000004  f44f727a          MOV      r2,#0x3e8
000008  f04f6100          MOV      r1,#0x8000000
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       TIMER_Open
000012  6820              LDR      r0,[r4,#0]
000014  f0405000          ORR      r0,r0,#0x20000000
000018  6020              STR      r0,[r4,#0]
;;;491        TIMER_EnableInt(TIMER1);
;;;492        NVIC_EnableIRQ(TMR1_IRQn);	
00001a  2021              MOVS     r0,#0x21
00001c  f7fffffe          BL       NVIC_EnableIRQ
000020  6820              LDR      r0,[r4,#0]
000022  f0404080          ORR      r0,r0,#0x40000000
000026  6020              STR      r0,[r4,#0]
;;;493        TIMER_Start(TIMER1);
;;;494    }
000028  bd10              POP      {r4,pc}
;;;495    
                          ENDP

00002a  0000              DCW      0x0000
                  |L14.44|
                          DCD      0x40050100

                          AREA ||i.TMR1_IRQHandler||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  TMR1_IRQHandler PROC
;;;458    
;;;459    void TMR1_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
000002  4817              LDR      r0,|L15.96|
000004  6881              LDR      r1,[r0,#8]
000006  f3c10100          UBFX     r1,r1,#0,#1
;;;460    {
00000a  2900              CMP      r1,#0
00000c  d026              BEQ      |L15.92|
00000e  2101              MOVS     r1,#1
000010  6081              STR      r1,[r0,#8]
;;;461    	static uint32_t LOG = 0;
;;;462    
;;;463    	
;;;464        if(TIMER_GetIntFlag(TIMER1) == 1)
;;;465        {
;;;466            TIMER_ClearIntFlag(TIMER1);
;;;467    		tick_counter();
000012  f7fffffe          BL       tick_counter
000016  4c13              LDR      r4,|L15.100|
;;;468    
;;;469    		if ((get_tick() % 10000) == 0)
000018  f2427110          MOV      r1,#0x2710
00001c  6860              LDR      r0,[r4,#4]  ; counter_tick
00001e  fbb0f2f1          UDIV     r2,r0,r1
000022  fb010012          MLS      r0,r1,r2,r0
000026  b930              CBNZ     r0,|L15.54|
;;;470    		{
;;;471            	printf("boot loader : %s : %4d\r\n",__FUNCTION__,LOG++);
000028  68a2              LDR      r2,[r4,#8]  ; LOG
00002a  490f              LDR      r1,|L15.104|
00002c  1c50              ADDS     r0,r2,#1
00002e  60a0              STR      r0,[r4,#8]  ; LOG
000030  a00e              ADR      r0,|L15.108|
000032  f7fffffe          BL       __2printf
                  |L15.54|
;;;472    		}
;;;473    
;;;474    		if ((get_tick() % 250) == 0)
000036  6860              LDR      r0,[r4,#4]  ; counter_tick
000038  21fa              MOVS     r1,#0xfa
00003a  fbb0f2f1          UDIV     r2,r0,r1
00003e  fb010012          MLS      r0,r1,r2,r0
000042  2800              CMP      r0,#0
000044  d10a              BNE      |L15.92|
;;;475    		{			
;;;476    			PH0 ^= 1;
000046  4810              LDR      r0,|L15.136|
000048  6801              LDR      r1,[r0,#0]
00004a  f0810101          EOR      r1,r1,#1
00004e  6001              STR      r1,[r0,#0]
;;;477    			PH4 ^= 1;
000050  480d              LDR      r0,|L15.136|
000052  3010              ADDS     r0,r0,#0x10
000054  6801              LDR      r1,[r0,#0]
000056  f0810101          EOR      r1,r1,#1
00005a  6001              STR      r1,[r0,#0]
                  |L15.92|
;;;478    		}
;;;479    
;;;480    		if ((get_tick() % 50) == 0)
;;;481    		{
;;;482    
;;;483    		}	
;;;484        }
;;;485    }
00005c  bd10              POP      {r4,pc}
;;;486    
                          ENDP

00005e  0000              DCW      0x0000
                  |L15.96|
                          DCD      0x40050100
                  |L15.100|
                          DCD      ||.data||
                  |L15.104|
                          DCD      ||.constdata||+0x5a
                  |L15.108|
00006c  626f6f74          DCB      "boot loader : %s : %4d\r\n",0
000070  206c6f61
000074  64657220
000078  3a202573
00007c  203a2025
000080  34640d0a
000084  00      
000085  00                DCB      0
000086  00                DCB      0
000087  00                DCB      0
                  |L15.136|
                          DCD      0x400049c0

                          AREA ||i.UART0_IRQHandler||, CODE, READONLY, ALIGN=2

                  UART0_IRQHandler PROC
;;;538    
;;;539    void UART0_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;540    {
;;;541        if(UART_GET_INT_FLAG(UART0, UART_INTSTS_RDAINT_Msk | UART_INTSTS_RXTOINT_Msk))     /* UART receive data available flag */
000002  4c0b              LDR      r4,|L16.48|
000004  69e0              LDR      r0,[r4,#0x1c]
000006  f4105f88          TST      r0,#0x1100
00000a  d102              BNE      |L16.18|
00000c  e004              B        |L16.24|
                  |L16.14|
;;;542        {
;;;543            while(UART_GET_RX_EMPTY(UART0) == 0)
;;;544            {
;;;545    			UARTx_Process();
00000e  f7fffffe          BL       UARTx_Process
                  |L16.18|
000012  69a1              LDR      r1,[r4,#0x18]         ;543
000014  0449              LSLS     r1,r1,#17             ;543
000016  d5fa              BPL      |L16.14|
                  |L16.24|
;;;546            }
;;;547        }
;;;548    
;;;549        if(UART0->FIFOSTS & (UART_FIFOSTS_BIF_Msk | UART_FIFOSTS_FEF_Msk | UART_FIFOSTS_PEF_Msk | UART_FIFOSTS_RXOVIF_Msk))
000018  69a1              LDR      r1,[r4,#0x18]
00001a  4620              MOV      r0,r4
00001c  f0110f71          TST      r1,#0x71
000020  d005              BEQ      |L16.46|
;;;550        {
;;;551            UART_ClearIntFlag(UART0, (UART_INTSTS_RLSINT_Msk| UART_INTSTS_BUFERRINT_Msk));
000022  e8bd4010          POP      {r4,lr}
000026  f44f5110          MOV      r1,#0x2400
00002a  f7ffbffe          B.W      UART_ClearIntFlag
                  |L16.46|
;;;552        }	
;;;553    }
00002e  bd10              POP      {r4,pc}
;;;554    
                          ENDP

                  |L16.48|
                          DCD      0x40070000

                          AREA ||i.UART0_Init||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  UART0_Init PROC
;;;554    
;;;555    void UART0_Init(void)
000000  b510              PUSH     {r4,lr}
;;;556    {
;;;557        SYS_ResetModule(UART0_RST);
000002  4818              LDR      r0,|L17.100|
000004  f7fffffe          BL       SYS_ResetModule
;;;558    
;;;559        /* Configure UART0 and set UART0 baud rate */
;;;560        UART_Open(UART0, 115200);
000008  4c17              LDR      r4,|L17.104|
00000a  f44f31e1          MOV      r1,#0x1c200
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       UART_Open
;;;561    
;;;562    	/* Set UART receive time-out */
;;;563    //	UART_SetTimeoutCnt(UART0, 20);
;;;564    
;;;565    //	UART0->FIFO &= ~UART_FIFO_RFITL_4BYTES;
;;;566    //	UART0->FIFO |= UART_FIFO_RFITL_8BYTES;
;;;567    
;;;568    	/* Enable UART Interrupt - */
;;;569    	UART_ENABLE_INT(UART0, UART_INTEN_RDAIEN_Msk | UART_INTEN_TOCNTEN_Msk | UART_INTEN_RXTOIEN_Msk);
000014  6861              LDR      r1,[r4,#4]
000016  f6400211          MOV      r2,#0x811
00001a  4311              ORRS     r1,r1,r2
00001c  6061              STR      r1,[r4,#4]
;;;570    	
;;;571    	NVIC_EnableIRQ(UART0_IRQn);
00001e  2024              MOVS     r0,#0x24
000020  f7fffffe          BL       NVIC_EnableIRQ
;;;572    
;;;573    	#if (_debug_log_UART_ == 1)	//debug
;;;574    	printf("\r\nCLK_GetCPUFreq : %8d\r\n",CLK_GetCPUFreq());
000024  f7fffffe          BL       CLK_GetCPUFreq
000028  4601              MOV      r1,r0
00002a  a010              ADR      r0,|L17.108|
00002c  f7fffffe          BL       __2printf
;;;575    	printf("CLK_GetHXTFreq : %8d\r\n",CLK_GetHXTFreq());
000030  f7fffffe          BL       CLK_GetHXTFreq
000034  4601              MOV      r1,r0
000036  a014              ADR      r0,|L17.136|
000038  f7fffffe          BL       __2printf
;;;576    	printf("CLK_GetLXTFreq : %8d\r\n",CLK_GetLXTFreq());	
00003c  f7fffffe          BL       CLK_GetLXTFreq
000040  4601              MOV      r1,r0
000042  a017              ADR      r0,|L17.160|
000044  f7fffffe          BL       __2printf
;;;577    	printf("CLK_GetPCLK0Freq : %8d\r\n",CLK_GetPCLK0Freq());
000048  f7fffffe          BL       CLK_GetPCLK0Freq
00004c  4601              MOV      r1,r0
00004e  a01a              ADR      r0,|L17.184|
000050  f7fffffe          BL       __2printf
;;;578    	printf("CLK_GetPCLK1Freq : %8d\r\n",CLK_GetPCLK1Freq());	
000054  f7fffffe          BL       CLK_GetPCLK1Freq
000058  4601              MOV      r1,r0
00005a  e8bd4010          POP      {r4,lr}
00005e  a01d              ADR      r0,|L17.212|
000060  f7ffbffe          B.W      __2printf
;;;579    	#endif
;;;580    }
;;;581    
                          ENDP

                  |L17.100|
                          DCD      0x04000010
                  |L17.104|
                          DCD      0x40070000
                  |L17.108|
00006c  0d0a434c          DCB      "\r\nCLK_GetCPUFreq : %8d\r\n",0
000070  4b5f4765
000074  74435055
000078  46726571
00007c  203a2025
000080  38640d0a
000084  00      
000085  00                DCB      0
000086  00                DCB      0
000087  00                DCB      0
                  |L17.136|
000088  434c4b5f          DCB      "CLK_GetHXTFreq : %8d\r\n",0
00008c  47657448
000090  58544672
000094  6571203a
000098  20253864
00009c  0d0a00  
00009f  00                DCB      0
                  |L17.160|
0000a0  434c4b5f          DCB      "CLK_GetLXTFreq : %8d\r\n",0
0000a4  4765744c
0000a8  58544672
0000ac  6571203a
0000b0  20253864
0000b4  0d0a00  
0000b7  00                DCB      0
                  |L17.184|
0000b8  434c4b5f          DCB      "CLK_GetPCLK0Freq : %8d\r\n",0
0000bc  47657450
0000c0  434c4b30
0000c4  46726571
0000c8  203a2025
0000cc  38640d0a
0000d0  00      
0000d1  00                DCB      0
0000d2  00                DCB      0
0000d3  00                DCB      0
                  |L17.212|
0000d4  434c4b5f          DCB      "CLK_GetPCLK1Freq : %8d\r\n",0
0000d8  47657450
0000dc  434c4b31
0000e0  46726571
0000e4  203a2025
0000e8  38640d0a
0000ec  00      
0000ed  00                DCB      0
0000ee  00                DCB      0
0000ef  00                DCB      0

                          AREA ||i.UARTx_Process||, CODE, READONLY, ALIGN=2

                  UARTx_Process PROC
;;;495    
;;;496    void UARTx_Process(void)
000000  480a              LDR      r0,|L18.44|
;;;497    {
000002  b510              PUSH     {r4,lr}
;;;498    	uint8_t res = 0;
;;;499    	res = UART_READ(UART0);
000004  6800              LDR      r0,[r0,#0]
000006  b2c0              UXTB     r0,r0
;;;500    
;;;501    	if (res == 'x' || res == 'X')
000008  2878              CMP      r0,#0x78
00000a  d00c              BEQ      |L18.38|
00000c  2858              CMP      r0,#0x58
00000e  d00a              BEQ      |L18.38|
;;;502    	{
;;;503    		NVIC_SystemReset();
;;;504    	}
;;;505    
;;;506    	if (res > 0x7F)
000010  287f              CMP      r0,#0x7f
000012  d904              BLS      |L18.30|
;;;507    	{
;;;508    		printf("invalid command\r\n");
000014  e8bd4010          POP      {r4,lr}
000018  a005              ADR      r0,|L18.48|
00001a  f7ffbffe          B.W      __2printf
                  |L18.30|
;;;509    	}
;;;510    	else
;;;511    	{
;;;512    		switch(res)
00001e  285a              CMP      r0,#0x5a
000020  d001              BEQ      |L18.38|
000022  287a              CMP      r0,#0x7a
000024  d101              BNE      |L18.42|
                  |L18.38|
;;;513    		{
;;;514    
;;;515    			#if defined (USE_MANUAL_UPDATE_FW)
;;;516    			case '1':
;;;517    				load_image_to_flash(FMC_CUSTOM_STORE_APROM01_BASE,0x2000,FMC_CUSTOM_APROM_BASE,0x2000);		
;;;518    				Jump_To_Application();
;;;519    				break;
;;;520    
;;;521    			case '2':
;;;522    				load_image_to_flash(FMC_CUSTOM_STORE_APROM02_BASE,0x2000,FMC_CUSTOM_APROM_BASE,0x2000);			
;;;523    				Jump_To_Application();
;;;524    				break;	
;;;525    			#endif
;;;526    
;;;527    
;;;528    			case 'X':
;;;529    			case 'x':
;;;530    			case 'Z':
;;;531    			case 'z':
;;;532    				NVIC_SystemReset();		
000026  f7fffffe          BL       NVIC_SystemReset
                  |L18.42|
;;;533    				break;
;;;534    		}
;;;535    	}
;;;536    }
00002a  bd10              POP      {r4,pc}
;;;537    
                          ENDP

                  |L18.44|
                          DCD      0x40070000
                  |L18.48|
000030  696e7661          DCB      "invalid command\r\n",0
000034  6c696420
000038  636f6d6d
00003c  616e640d
000040  0a00    
000042  00                DCB      0
000043  00                DCB      0

                          AREA ||i.check_reset_source||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  check_reset_source PROC
;;;191    
;;;192    uint8_t check_reset_source(void)
000000  b570              PUSH     {r4-r6,lr}
;;;193    {
;;;194        uint8_t tag;
;;;195        uint32_t src = SYS_GetResetSrc();
000002  f7fffffe          BL       SYS_GetResetSrc
000006  4605              MOV      r5,r0
;;;196    
;;;197        SYS->RSTSTS |= 0x1FF;
000008  f04f4080          MOV      r0,#0x40000000
00000c  6841              LDR      r1,[r0,#4]
00000e  f24012ff          MOV      r2,#0x1ff
000012  4311              ORRS     r1,r1,r2
000014  6041              STR      r1,[r0,#4]
;;;198        printf("Reset Source <0x%08X>\r\n", src);
000016  4629              MOV      r1,r5
000018  a014              ADR      r0,|L19.108|
00001a  f7fffffe          BL       __2printf
;;;199       
;;;200        tag = rtc_read_magic_tag();
00001e  f7fffffe          BL       rtc_read_magic_tag
000022  4604              MOV      r4,r0
;;;201        
;;;202        if (src & SYS_RSTSTS_PORF_Msk) 
000024  07e8              LSLS     r0,r5,#31
000026  d015              BEQ      |L19.84|
;;;203    	{
;;;204            SYS_ClearResetSrc(SYS_RSTSTS_PORF_Msk);
000028  2001              MOVS     r0,#1
00002a  f7fffffe          BL       SYS_ClearResetSrc
;;;205            
;;;206            if (tag == 0xA5) 
00002e  2ca5              CMP      r4,#0xa5
000030  d003              BEQ      |L19.58|
;;;207    		{
;;;208                rtc_write_magic_tag(0);
;;;209                printf("Enter BOOTLOADER from APPLICATION\r\n");
;;;210                return TRUE;
;;;211            } 
;;;212    		else if (tag == 0xBB) 
000032  2cbb              CMP      r4,#0xbb
000034  d009              BEQ      |L19.74|
;;;213    		{
;;;214                rtc_write_magic_tag(0);
;;;215                printf("from other source\r\n");
;;;216                return FALSE;
;;;217            } 
;;;218    		else 
;;;219    		{
;;;220                printf("Enter BOOTLOADER from POR\r\n");
000036  a013              ADR      r0,|L19.132|
;;;221                return FALSE;
000038  e012              B        |L19.96|
                  |L19.58|
00003a  2000              MOVS     r0,#0                 ;208
00003c  f7fffffe          BL       rtc_write_magic_tag
000040  a017              ADR      r0,|L19.160|
000042  f7fffffe          BL       __2printf
000046  2001              MOVS     r0,#1                 ;210
;;;222            }
;;;223        } 
;;;224    	else if (src & SYS_RSTSTS_PINRF_Msk)
;;;225    	{
;;;226            SYS_ClearResetSrc(SYS_RSTSTS_PINRF_Msk);
;;;227            printf("Enter BOOTLOADER from nRESET pin\r\n");
;;;228            return FALSE;
;;;229        }
;;;230        
;;;231        printf("Enter BOOTLOADER from unhandle reset source\r\n");
;;;232        return FALSE;
;;;233    }
000048  bd70              POP      {r4-r6,pc}
                  |L19.74|
00004a  2000              MOVS     r0,#0                 ;214
00004c  f7fffffe          BL       rtc_write_magic_tag
000050  a01c              ADR      r0,|L19.196|
000052  e005              B        |L19.96|
                  |L19.84|
000054  07a8              LSLS     r0,r5,#30             ;224
000056  d507              BPL      |L19.104|
000058  2002              MOVS     r0,#2                 ;226
00005a  f7fffffe          BL       SYS_ClearResetSrc
00005e  a01e              ADR      r0,|L19.216|
                  |L19.96|
000060  f7fffffe          BL       __2printf
000064  2000              MOVS     r0,#0                 ;232
000066  bd70              POP      {r4-r6,pc}
                  |L19.104|
000068  a024              ADR      r0,|L19.252|
00006a  e7f9              B        |L19.96|
;;;234    
                          ENDP

                  |L19.108|
00006c  52657365          DCB      "Reset Source <0x%08X>\r\n",0
000070  7420536f
000074  75726365
000078  203c3078
00007c  25303858
000080  3e0d0a00
                  |L19.132|
000084  456e7465          DCB      "Enter BOOTLOADER from POR\r\n",0
000088  7220424f
00008c  4f544c4f
000090  41444552
000094  2066726f
000098  6d20504f
00009c  520d0a00
                  |L19.160|
0000a0  456e7465          DCB      "Enter BOOTLOADER from APPLICATION\r\n",0
0000a4  7220424f
0000a8  4f544c4f
0000ac  41444552
0000b0  2066726f
0000b4  6d204150
0000b8  504c4943
0000bc  4154494f
0000c0  4e0d0a00
                  |L19.196|
0000c4  66726f6d          DCB      "from other source\r\n",0
0000c8  206f7468
0000cc  65722073
0000d0  6f757263
0000d4  650d0a00
                  |L19.216|
0000d8  456e7465          DCB      "Enter BOOTLOADER from nRESET pin\r\n",0
0000dc  7220424f
0000e0  4f544c4f
0000e4  41444552
0000e8  2066726f
0000ec  6d206e52
0000f0  45534554
0000f4  2070696e
0000f8  0d0a00  
0000fb  00                DCB      0
                  |L19.252|
0000fc  456e7465          DCB      "Enter BOOTLOADER from unhandle reset source\r\n",0
000100  7220424f
000104  4f544c4f
000108  41444552
00010c  2066726f
000110  6d20756e
000114  68616e64
000118  6c652072
00011c  65736574
000120  20736f75
000124  7263650d
000128  0a00    
00012a  00                DCB      0
00012b  00                DCB      0

                          AREA ||i.compare_buffer||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_x
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                  compare_buffer PROC
;;;45     
;;;46     void compare_buffer(uint8_t *src, uint8_t *des, int nBytes)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;47     {
000004  4616              MOV      r6,r2
000006  460f              MOV      r7,r1
000008  4680              MOV      r8,r0
;;;48         uint16_t i = 0;	
00000a  2400              MOVS     r4,#0
;;;49     	
;;;50         for (i = 0; i < nBytes; i++)
;;;51         {
;;;52             if (src[i] != des[i])
;;;53             {
;;;54                 printf("error idx : %4d : 0x%2X , 0x%2X\r\n", i , src[i],des[i]);
;;;55     			set_flag(flag_error , ENABLE);
00000c  4d0f              LDR      r5,|L20.76|
00000e  e00e              B        |L20.46|
                  |L20.16|
000010  f8182004          LDRB     r2,[r8,r4]            ;52
000014  5d3b              LDRB     r3,[r7,r4]            ;52
000016  429a              CMP      r2,r3                 ;52
000018  d007              BEQ      |L20.42|
00001a  4621              MOV      r1,r4                 ;54
00001c  a00c              ADR      r0,|L20.80|
00001e  f7fffffe          BL       __2printf
000022  6828              LDR      r0,[r5,#0]  ; BitFlag
000024  f0400004          ORR      r0,r0,#4
000028  6028              STR      r0,[r5,#0]  ; BitFlag
                  |L20.42|
00002a  1c64              ADDS     r4,r4,#1
00002c  b2a4              UXTH     r4,r4                 ;50
                  |L20.46|
00002e  42b4              CMP      r4,r6                 ;50
000030  dbee              BLT      |L20.16|
;;;56             }
;;;57         }
;;;58     
;;;59     	if (!is_flag_set(flag_error))
000032  6828              LDR      r0,[r5,#0]  ; BitFlag
000034  0740              LSLS     r0,r0,#29
000036  d407              BMI      |L20.72|
;;;60     	{
;;;61         	printf("%s finish \r\n" , __FUNCTION__);	
000038  490e              LDR      r1,|L20.116|
00003a  a00f              ADR      r0,|L20.120|
00003c  f7fffffe          BL       __2printf
;;;62     		set_flag(flag_error , DISABLE);
000040  6828              LDR      r0,[r5,#0]  ; BitFlag
000042  f0200004          BIC      r0,r0,#4
000046  6028              STR      r0,[r5,#0]  ; BitFlag
                  |L20.72|
;;;63     	}
;;;64     
;;;65     }
000048  e8bd81f0          POP      {r4-r8,pc}
;;;66     
                          ENDP

                  |L20.76|
                          DCD      ||.data||
                  |L20.80|
000050  6572726f          DCB      "error idx : %4d : 0x%2X , 0x%2X\r\n",0
000054  72206964
000058  78203a20
00005c  25346420
000060  3a203078
000064  25325820
000068  2c203078
00006c  2532580d
000070  0a00    
000072  00                DCB      0
000073  00                DCB      0
                  |L20.116|
                          DCD      ||.constdata||+0x8
                  |L20.120|
000078  25732066          DCB      "%s finish \r\n",0
00007c  696e6973
000080  68200d0a
000084  00      
000085  00                DCB      0
000086  00                DCB      0
000087  00                DCB      0

                          AREA ||i.copy_buffer||, CODE, READONLY, ALIGN=1

                  copy_buffer PROC
;;;82     
;;;83     void copy_buffer(void *dest, void *src, unsigned int size)
000000  b510              PUSH     {r4,lr}
;;;84     {
;;;85         uint8_t *pu8Src, *pu8Dest;
;;;86         unsigned int i;
;;;87         
;;;88         pu8Dest = (uint8_t *)dest;
;;;89         pu8Src  = (uint8_t *)src;
;;;90     
;;;91     
;;;92     	#if 0
;;;93     	  while (size--)
;;;94     	    *pu8Dest++ = *pu8Src++;
;;;95     	#else
;;;96         for (i = 0; i < size; i++)
000002  2300              MOVS     r3,#0
000004  e002              B        |L21.12|
                  |L21.6|
;;;97             pu8Dest[i] = pu8Src[i];
000006  5ccc              LDRB     r4,[r1,r3]
000008  54c4              STRB     r4,[r0,r3]
00000a  1c5b              ADDS     r3,r3,#1
                  |L21.12|
00000c  4293              CMP      r3,r2                 ;96
00000e  d3fa              BCC      |L21.6|
;;;98     	#endif
;;;99     }
000010  bd10              POP      {r4,pc}
;;;100    
                          ENDP


                          AREA ||i.delay||, CODE, READONLY, ALIGN=1

                  delay PROC
                  |L22.0|
;;;141    
;;;142    void delay(uint16_t dly)
000000  1e40              SUBS     r0,r0,#1
;;;143    {
;;;144    /*
;;;145    	delay(100) : 14.84 us
;;;146    	delay(200) : 29.37 us
;;;147    	delay(300) : 43.97 us
;;;148    	delay(400) : 58.5 us	
;;;149    	delay(500) : 73.13 us	
;;;150    	
;;;151    	delay(1500) : 0.218 ms (218 us)
;;;152    	delay(2000) : 0.291 ms (291 us)	
;;;153    */
;;;154    
;;;155    	while( dly--);
000002  b280              UXTH     r0,r0
000004  d2fc              BCS      |L22.0|
;;;156    }
000006  4770              BX       lr
;;;157    
                          ENDP


                          AREA ||i.delay_ms||, CODE, READONLY, ALIGN=2

                  delay_ms PROC
;;;158    
;;;159    void delay_ms(uint16_t ms)
000000  f44f717a          MOV      r1,#0x3e8
;;;160    {
;;;161    	TIMER_Delay(TIMER0, 1000*ms);
000004  4341              MULS     r1,r0,r1
000006  4801              LDR      r0,|L23.12|
000008  f7ffbffe          B.W      TIMER_Delay
;;;162    }
;;;163    
                          ENDP

                  |L23.12|
                          DCD      0x40050000

                          AREA ||i.dump_buffer||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  dump_buffer PROC
;;;100    
;;;101    void dump_buffer(uint8_t *pucBuff, int nBytes)
000000  b570              PUSH     {r4-r6,lr}
;;;102    {
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
;;;103        uint16_t i = 0;
000006  2400              MOVS     r4,#0
;;;104        
;;;105        printf("dump_buffer : %2d\r\n" , nBytes);    
000008  a00b              ADR      r0,|L24.56|
00000a  f7fffffe          BL       __2printf
;;;106        for (i = 0 ; i < nBytes ; i++)
00000e  e00c              B        |L24.42|
                  |L24.16|
;;;107        {
;;;108            printf("0x%2X," , pucBuff[i]);
000010  5d31              LDRB     r1,[r6,r4]
000012  a00e              ADR      r0,|L24.76|
000014  f7fffffe          BL       __2printf
;;;109            if ((i+1)%8 ==0)
000018  0760              LSLS     r0,r4,#29
00001a  f1b04f60          CMP      r0,#0xe0000000
00001e  d102              BNE      |L24.38|
;;;110            {
;;;111                printf("\r\n");
000020  a00c              ADR      r0,|L24.84|
000022  f7fffffe          BL       __2printf
                  |L24.38|
000026  1c64              ADDS     r4,r4,#1
000028  b2a4              UXTH     r4,r4                 ;106
                  |L24.42|
00002a  42ac              CMP      r4,r5                 ;106
00002c  dbf0              BLT      |L24.16|
;;;112            }            
;;;113        }
;;;114        printf("\r\n\r\n");
00002e  e8bd4070          POP      {r4-r6,lr}
000032  a009              ADR      r0,|L24.88|
000034  f7ffbffe          B.W      __2printf
;;;115    }
;;;116    
                          ENDP

                  |L24.56|
000038  64756d70          DCB      "dump_buffer : %2d\r\n",0
00003c  5f627566
000040  66657220
000044  3a202532
000048  640d0a00
                  |L24.76|
00004c  30782532          DCB      "0x%2X,",0
000050  582c00  
000053  00                DCB      0
                  |L24.84|
000054  0d0a00            DCB      "\r\n",0
000057  00                DCB      0
                  |L24.88|
000058  0d0a0d0a          DCB      "\r\n\r\n",0
00005c  00      
00005d  00                DCB      0
00005e  00                DCB      0
00005f  00                DCB      0

                          AREA ||i.dump_buffer_hex||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_c
                          REQUIRE _printf_str
                  dump_buffer_hex PROC
;;;116    
;;;117    void  dump_buffer_hex(uint8_t *pucBuff, int nBytes)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;118    {
000004  460e              MOV      r6,r1
000006  4607              MOV      r7,r0
;;;119        int     nIdx, i;
;;;120    
;;;121        nIdx = 0;
000008  2500              MOVS     r5,#0
00000a  e025              B        |L25.88|
                  |L25.12|
;;;122        while (nBytes > 0)
;;;123        {
;;;124            printf("0x%04X  ", nIdx);
00000c  4629              MOV      r1,r5
00000e  a016              ADR      r0,|L25.104|
000010  f7fffffe          BL       __2printf
;;;125            for (i = 0; i < 16; i++)
000014  2400              MOVS     r4,#0
                  |L25.22|
;;;126                printf("%02X ", pucBuff[nIdx + i]);
000016  1928              ADDS     r0,r5,r4
000018  5c39              LDRB     r1,[r7,r0]
00001a  a016              ADR      r0,|L25.116|
00001c  f7fffffe          BL       __2printf
000020  1c64              ADDS     r4,r4,#1
000022  2c10              CMP      r4,#0x10              ;125
000024  dbf7              BLT      |L25.22|
;;;127            printf("  ");
000026  a015              ADR      r0,|L25.124|
000028  f7fffffe          BL       __2printf
;;;128            for (i = 0; i < 16; i++)
00002c  2400              MOVS     r4,#0
                  |L25.46|
;;;129            {
;;;130                if ((pucBuff[nIdx + i] >= 0x20) && (pucBuff[nIdx + i] < 127))
00002e  1928              ADDS     r0,r5,r4
000030  5c39              LDRB     r1,[r7,r0]
000032  f1a10020          SUB      r0,r1,#0x20
000036  285f              CMP      r0,#0x5f
000038  d203              BCS      |L25.66|
;;;131                    printf("%c", pucBuff[nIdx + i]);
00003a  a011              ADR      r0,|L25.128|
00003c  f7fffffe          BL       __2printf
000040  e002              B        |L25.72|
                  |L25.66|
;;;132                else
;;;133                    printf(".");
000042  a010              ADR      r0,|L25.132|
000044  f7fffffe          BL       __2printf
                  |L25.72|
000048  1c64              ADDS     r4,r4,#1
00004a  1e76              SUBS     r6,r6,#1
00004c  2c10              CMP      r4,#0x10              ;128
00004e  dbee              BLT      |L25.46|
;;;134                nBytes--;
;;;135            }
;;;136            nIdx += 16;
;;;137            printf("\n");
000050  a00d              ADR      r0,|L25.136|
000052  3510              ADDS     r5,r5,#0x10
000054  f7fffffe          BL       __2printf
                  |L25.88|
000058  2e00              CMP      r6,#0                 ;122
00005a  dcd7              BGT      |L25.12|
;;;138        }
;;;139        printf("\n");
00005c  e8bd41f0          POP      {r4-r8,lr}
000060  a009              ADR      r0,|L25.136|
000062  f7ffbffe          B.W      __2printf
;;;140    }
;;;141    
                          ENDP

000066  0000              DCW      0x0000
                  |L25.104|
000068  30782530          DCB      "0x%04X  ",0
00006c  34582020
000070  00      
000071  00                DCB      0
000072  00                DCB      0
000073  00                DCB      0
                  |L25.116|
000074  25303258          DCB      "%02X ",0
000078  2000    
00007a  00                DCB      0
00007b  00                DCB      0
                  |L25.124|
00007c  202000            DCB      "  ",0
00007f  00                DCB      0
                  |L25.128|
000080  256300            DCB      "%c",0
000083  00                DCB      0
                  |L25.132|
000084  2e00              DCB      ".",0
000086  00                DCB      0
000087  00                DCB      0
                  |L25.136|
000088  0a00              DCB      "\n",0
00008a  00                DCB      0
00008b  00                DCB      0

                          AREA ||i.get_tick||, CODE, READONLY, ALIGN=2

                  get_tick PROC
;;;35     
;;;36     uint32_t get_tick(void)
000000  4801              LDR      r0,|L26.8|
;;;37     {
;;;38     	return (counter_tick);
000002  6840              LDR      r0,[r0,#4]  ; counter_tick
;;;39     }
000004  4770              BX       lr
;;;40     
                          ENDP

000006  0000              DCW      0x0000
                  |L26.8|
                          DCD      ||.data||

                          AREA ||i.load_image_to_flash||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                  load_image_to_flash PROC
;;;249    
;;;250    int  load_image_to_flash(uint32_t image_base, uint32_t image_limit, uint32_t flash_addr, uint32_t max_size)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;251    {
000004  4605              MOV      r5,r0
;;;252        uint32_t   i, j, u32Data, u32ImageSize, *pu32Loader;
;;;253    
;;;254        u32ImageSize = max_size;
;;;255    
;;;256        printf("image_base address 0x%2X...\r\n", image_base);
000006  4601              MOV      r1,r0
000008  461e              MOV      r6,r3                 ;251
00000a  4690              MOV      r8,r2                 ;251
00000c  a02d              ADR      r0,|L27.196|
00000e  f7fffffe          BL       __2printf
;;;257        printf("Program image to flash address 0x%2X...\r\n", flash_addr);
000012  4641              MOV      r1,r8
000014  a033              ADR      r0,|L27.228|
000016  f7fffffe          BL       __2printf
;;;258    
;;;259    	FMC_Enable();
00001a  f7fffffe          BL       FMC_Enable
;;;260    
;;;261        /*
;;;262         * program the whole image to specified flash area
;;;263         */
;;;264        pu32Loader = (uint32_t *)image_base;
;;;265        for (i = 0; i < u32ImageSize; i += FMC_FLASH_PAGE_SIZE)
00001e  2700              MOVS     r7,#0
;;;266        {
;;;267    
;;;268            FMC_Erase(flash_addr + i);
;;;269            for (j = 0; j < FMC_FLASH_PAGE_SIZE; j += 4)
000020  f44f5a80          MOV      r10,#0x1000
000024  e012              B        |L27.76|
                  |L27.38|
000026  eb080007          ADD      r0,r8,r7              ;268
00002a  4681              MOV      r9,r0                 ;268
00002c  f7fffffe          BL       FMC_Erase
000030  2400              MOVS     r4,#0
                  |L27.50|
;;;270            {
;;;271                FMC_Write(flash_addr + i + j, pu32Loader[(i + j) / 4]);
000032  1938              ADDS     r0,r7,r4
000034  f0200003          BIC      r0,r0,#3
000038  5829              LDR      r1,[r5,r0]
00003a  eb090004          ADD      r0,r9,r4
00003e  f7fffffe          BL       FMC_Write
000042  1d24              ADDS     r4,r4,#4
000044  4554              CMP      r4,r10                ;269
000046  d3f4              BCC      |L27.50|
000048  f5075780          ADD      r7,r7,#0x1000         ;269
                  |L27.76|
00004c  42b7              CMP      r7,r6                 ;265
00004e  d3ea              BCC      |L27.38|
;;;272            }
;;;273        }
;;;274        printf("OK.\nVerify ...");
000050  a02f              ADR      r0,|L27.272|
000052  f7fffffe          BL       __2printf
;;;275    
;;;276        /* Verify loader */
;;;277        for (i = 0; i < u32ImageSize; i += FMC_FLASH_PAGE_SIZE)
000056  2700              MOVS     r7,#0
000058  e022              B        |L27.160|
                  |L27.90|
;;;278        {
;;;279            for (j = 0; j < FMC_FLASH_PAGE_SIZE; j += 4)
00005a  2400              MOVS     r4,#0
00005c  eb080907          ADD      r9,r8,r7              ;268
                  |L27.96|
;;;280            {
;;;281                u32Data = FMC_Read(flash_addr + i + j);
000060  eb090004          ADD      r0,r9,r4
000064  f7fffffe          BL       FMC_Read
000068  4602              MOV      r2,r0
;;;282    
;;;283                if (u32Data != pu32Loader[(i+j)/4])
00006a  1938              ADDS     r0,r7,r4
00006c  f0200103          BIC      r1,r0,#3
000070  5869              LDR      r1,[r5,r1]
000072  4291              CMP      r1,r2
000074  d00d              BEQ      |L27.146|
;;;284                {
;;;285                    printf("data mismatch on 0x%x, [0x%x], [0x%x]\n", flash_addr + i + j, u32Data, pu32Loader[(i+j)/4]);
000076  1938              ADDS     r0,r7,r4
000078  f0200003          BIC      r0,r0,#3
00007c  582b              LDR      r3,[r5,r0]
00007e  eb080007          ADD      r0,r8,r7
000082  1901              ADDS     r1,r0,r4
000084  a026              ADR      r0,|L27.288|
000086  f7fffffe          BL       __2printf
;;;286                    return -1;
00008a  f04f30ff          MOV      r0,#0xffffffff
                  |L27.142|
;;;287                }
;;;288    
;;;289                if (i + j >= u32ImageSize)
;;;290                    break;
;;;291            }
;;;292        }
;;;293        printf("OK.\n");
;;;294    
;;;295        printf("boot loader : %s\r\n", __FUNCTION__);
;;;296    
;;;297        while(IsDebugFifoEmpty() == 0);
;;;298    
;;;299    	FMC_Disable();
;;;300    	
;;;301        return 0;
;;;302    }
00008e  e8bd87f0          POP      {r4-r10,pc}
                  |L27.146|
000092  42b0              CMP      r0,r6                 ;289
000094  d202              BCS      |L27.156|
000096  1d24              ADDS     r4,r4,#4              ;289
000098  4554              CMP      r4,r10                ;279
00009a  d3e1              BCC      |L27.96|
                  |L27.156|
00009c  f5075780          ADD      r7,r7,#0x1000         ;279
                  |L27.160|
0000a0  42b7              CMP      r7,r6                 ;277
0000a2  d3da              BCC      |L27.90|
0000a4  a028              ADR      r0,|L27.328|
0000a6  f7fffffe          BL       __2printf
0000aa  4929              LDR      r1,|L27.336|
0000ac  a029              ADR      r0,|L27.340|
0000ae  f7fffffe          BL       __2printf
                  |L27.178|
0000b2  f7fffffe          BL       IsDebugFifoEmpty
0000b6  2800              CMP      r0,#0                 ;297
0000b8  d0fb              BEQ      |L27.178|
0000ba  f7fffffe          BL       FMC_Disable
0000be  2000              MOVS     r0,#0                 ;301
0000c0  e7e5              B        |L27.142|
;;;303    
                          ENDP

0000c2  0000              DCW      0x0000
                  |L27.196|
0000c4  696d6167          DCB      "image_base address 0x%2X...\r\n",0
0000c8  655f6261
0000cc  73652061
0000d0  64647265
0000d4  73732030
0000d8  78253258
0000dc  2e2e2e0d
0000e0  0a00    
0000e2  00                DCB      0
0000e3  00                DCB      0
                  |L27.228|
0000e4  50726f67          DCB      "Program image to flash address 0x%2X...\r\n",0
0000e8  72616d20
0000ec  696d6167
0000f0  6520746f
0000f4  20666c61
0000f8  73682061
0000fc  64647265
000100  73732030
000104  78253258
000108  2e2e2e0d
00010c  0a00    
00010e  00                DCB      0
00010f  00                DCB      0
                  |L27.272|
000110  4f4b2e0a          DCB      "OK.\nVerify ...",0
000114  56657269
000118  6679202e
00011c  2e2e00  
00011f  00                DCB      0
                  |L27.288|
000120  64617461          DCB      "data mismatch on 0x%x, [0x%x], [0x%x]\n",0
000124  206d6973
000128  6d617463
00012c  68206f6e
000130  20307825
000134  782c205b
000138  30782578
00013c  5d2c205b
000140  30782578
000144  5d0a00  
000147  00                DCB      0
                  |L27.328|
000148  4f4b2e0a          DCB      "OK.\n",0
00014c  00      
00014d  00                DCB      0
00014e  00                DCB      0
00014f  00                DCB      0
                  |L27.336|
                          DCD      ||.constdata||+0x17
                  |L27.340|
000154  626f6f74          DCB      "boot loader : %s\r\n",0
000158  206c6f61
00015c  64657220
000160  3a202573
000164  0d0a00  
000167  00                DCB      0

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;649    
;;;650    int main()
000000  f7fffffe          BL       SYS_Init
;;;651    {
;;;652        SYS_Init();
;;;653    
;;;654    	UART0_Init();
000004  f7fffffe          BL       UART0_Init
;;;655    	Custom_Init();	
000008  f7fffffe          BL       Custom_Init
;;;656    	TIMER1_Init();
00000c  f7fffffe          BL       TIMER1_Init
;;;657    
;;;658    	FMC_Enable();
000010  f7fffffe          BL       FMC_Enable
;;;659    	set_IAP_boot_mode();
000014  f7fffffe          BL       set_IAP_boot_mode
;;;660    	Read_BS();
000018  f7fffffe          BL       Read_BS
;;;661    	set_FW_update_TimeOut();
00001c  f7fffffe          BL       set_FW_update_TimeOut
;;;662    	FMC_Disable();
000020  f7fffffe          BL       FMC_Disable
;;;663    	
;;;664    	#if defined (USE_MANUAL_UPDATE_FW)
;;;665    	Manual_update_FW();
;;;666    	#endif
;;;667    
;;;668    	check_reset_source();
000024  f7fffffe          BL       check_reset_source
;;;669    	
;;;670        while(1)
;;;671        {
;;;672    		#if defined (USE_EMULATE_AUTO_JUMP)
;;;673    		if (is_flag_set(flag_update_fw))
000028  4c05              LDR      r4,|L28.64|
                  |L28.42|
00002a  6820              LDR      r0,[r4,#0]  ; BitFlag
00002c  0780              LSLS     r0,r0,#30
00002e  d402              BMI      |L28.54|
;;;674    		{
;;;675    			// process update firmwar flow
;;;676    			break;
;;;677    		}
;;;678    
;;;679    		
;;;680    		// if no need to update firmware , wait for timeout to app.
;;;681    		Check_if_FW_update_TimeOut();
000030  f7fffffe          BL       Check_if_FW_update_TimeOut
000034  e7f9              B        |L28.42|
                  |L28.54|
;;;682    		#endif
;;;683    		
;;;684        }
;;;685    
;;;686        /* Got no where to go, just loop forever */
;;;687        while(1)
;;;688        {
;;;689        	printf("boot loader : while(1)\r\n");
000036  a003              ADR      r0,|L28.68|
000038  f7fffffe          BL       __2printf
00003c  e7fb              B        |L28.54|
;;;690        }
;;;691    
;;;692    	
;;;693    }
;;;694    
                          ENDP

00003e  0000              DCW      0x0000
                  |L28.64|
                          DCD      ||.data||
                  |L28.68|
000044  626f6f74          DCB      "boot loader : while(1)\r\n",0
000048  206c6f61
00004c  64657220
000050  3a207768
000054  696c6528
000058  31290d0a
00005c  00      
00005d  00                DCB      0
00005e  00                DCB      0
00005f  00                DCB      0

                          AREA ||i.resetPeripherals||, CODE, READONLY, ALIGN=2

                  resetPeripherals PROC
;;;365    //
;;;366    void resetPeripherals(void)
000000  b510              PUSH     {r4,lr}
;;;367    {
;;;368        /* Note: Remember disable all of peripherals interrupt used in the application 
;;;369            before jump to app.*/
;;;370    	NVIC_DisableIRQ(UART0_IRQn);
000002  2024              MOVS     r0,#0x24
000004  f7fffffe          BL       NVIC_DisableIRQ
;;;371    	NVIC_DisableIRQ(TMR1_IRQn);
000008  2021              MOVS     r0,#0x21
00000a  f7fffffe          BL       NVIC_DisableIRQ
;;;372    
;;;373    
;;;374    	 
;;;375        /* Note: Remember reset all of peripherals used in the application 
;;;376            before jump to app. */
;;;377        SYS_ResetModule(UART0_IRQn);
00000e  2024              MOVS     r0,#0x24
000010  f7fffffe          BL       SYS_ResetModule
;;;378        SYS_ResetModule(TMR1_RST);
000014  e8bd4010          POP      {r4,lr}
000018  4801              LDR      r0,|L29.32|
00001a  f7ffbffe          B.W      SYS_ResetModule
;;;379    }
;;;380    
                          ENDP

00001e  0000              DCW      0x0000
                  |L29.32|
                          DCD      0x04000003

                          AREA ||i.reset_buffer||, CODE, READONLY, ALIGN=1

                  reset_buffer PROC
;;;66     
;;;67     void reset_buffer(void *dest, unsigned int val, unsigned int size)
000000  b2c9              UXTB     r1,r1
;;;68     {
000002  e001              B        |L30.8|
                  |L30.4|
;;;69         uint8_t *pu8Dest;
;;;70     //    unsigned int i;
;;;71         
;;;72         pu8Dest = (uint8_t *)dest;
;;;73     
;;;74     	#if 1
;;;75     	while (size-- > 0)
;;;76     		*pu8Dest++ = val;
000004  f8001b01          STRB     r1,[r0],#1
                  |L30.8|
000008  1e52              SUBS     r2,r2,#1
00000a  d2fb              BCS      |L30.4|
;;;77     	#else
;;;78     	memset(pu8Dest, val, size * (sizeof(pu8Dest[0]) ));
;;;79     	#endif
;;;80     	
;;;81     }
00000c  4770              BX       lr
;;;82     
                          ENDP


                          AREA ||i.rtc_read_magic_tag||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  rtc_read_magic_tag PROC
;;;175    
;;;176    uint8_t rtc_read_magic_tag(void)
000000  b510              PUSH     {r4,lr}
;;;177    {
;;;178        uint8_t tag;
;;;179        
;;;180        RTC_EnableSpareAccess();
000002  f7fffffe          BL       RTC_EnableSpareAccess
;;;181    
;;;182        RTC->RWEN = RTC_WRITE_KEY;
000006  4807              LDR      r0,|L31.36|
000008  f64a1165          MOV      r1,#0xa965
00000c  6041              STR      r1,[r0,#4]
                  |L31.14|
;;;183        while(!(RTC->RWEN & RTC_RWEN_RWENF_Msk));
00000e  6841              LDR      r1,[r0,#4]
000010  03c9              LSLS     r1,r1,#15
000012  d5fc              BPL      |L31.14|
;;;184        
;;;185        tag =  RTC_READ_SPARE_REGISTER(0);
000014  6c00              LDR      r0,[r0,#0x40]
000016  b2c4              UXTB     r4,r0
;;;186    
;;;187        printf("Raed MagicTag <0x%02X>\r\n", tag);
000018  4621              MOV      r1,r4
00001a  a003              ADR      r0,|L31.40|
00001c  f7fffffe          BL       __2printf
;;;188        
;;;189        return tag;
000020  4620              MOV      r0,r4
;;;190    }
000022  bd10              POP      {r4,pc}
;;;191    
                          ENDP

                  |L31.36|
                          DCD      0x40041000
                  |L31.40|
000028  52616564          DCB      "Raed MagicTag <0x%02X>\r\n",0
00002c  204d6167
000030  69635461
000034  67203c30
000038  78253032
00003c  583e0d0a
000040  00      
000041  00                DCB      0
000042  00                DCB      0
000043  00                DCB      0

                          AREA ||i.rtc_write_magic_tag||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  rtc_write_magic_tag PROC
;;;163    
;;;164    void rtc_write_magic_tag(uint8_t tag)
000000  b510              PUSH     {r4,lr}
;;;165    {
000002  4604              MOV      r4,r0
;;;166        RTC_EnableSpareAccess();
000004  f7fffffe          BL       RTC_EnableSpareAccess
;;;167    
;;;168        RTC->RWEN = RTC_WRITE_KEY;
000008  4a06              LDR      r2,|L32.36|
00000a  f64a1065          MOV      r0,#0xa965
00000e  6050              STR      r0,[r2,#4]
                  |L32.16|
;;;169        while(!(RTC->RWEN & RTC_RWEN_RWENF_Msk));
000010  6853              LDR      r3,[r2,#4]
000012  03db              LSLS     r3,r3,#15
000014  d5fc              BPL      |L32.16|
;;;170        
;;;171        RTC_WRITE_SPARE_REGISTER(0, tag);
000016  6414              STR      r4,[r2,#0x40]
;;;172        
;;;173        printf("Write MagicTag <0x%02X>\r\n", tag);
000018  4621              MOV      r1,r4
00001a  e8bd4010          POP      {r4,lr}
00001e  a002              ADR      r0,|L32.40|
000020  f7ffbffe          B.W      __2printf
;;;174    }
;;;175    
                          ENDP

                  |L32.36|
                          DCD      0x40041000
                  |L32.40|
000028  57726974          DCB      "Write MagicTag <0x%02X>\r\n",0
00002c  65204d61
000030  67696354
000034  6167203c
000038  30782530
00003c  32583e0d
000040  0a00    
000042  00                DCB      0
000043  00                DCB      0

                          AREA ||i.set_FW_update_TimeOut||, CODE, READONLY, ALIGN=2

                  set_FW_update_TimeOut PROC
;;;403    
;;;404    void set_FW_update_TimeOut(void)
000000  f04f4080          MOV      r0,#0x40000000
;;;405    {
;;;406    
;;;407        CLK->AHBCLK |= CLK_AHBCLK_ISPCKEN_Msk;
000004  f8d01204          LDR      r1,[r0,#0x204]
000008  f0410104          ORR      r1,r1,#4
00000c  f8c01204          STR      r1,[r0,#0x204]
;;;408    
;;;409    	FMC_ENABLE_ISP();
000010  480b              LDR      r0,|L33.64|
000012  6801              LDR      r1,[r0,#0]
000014  f0410101          ORR      r1,r1,#1
000018  6001              STR      r1,[r0,#0]
;;;410        FMC_ENABLE_AP_UPDATE();//FMC->ISPCTL |= (FMC_ISPCTL_ISPEN_Msk | FMC_ISPCTL_APUEN_Msk);
00001a  6801              LDR      r1,[r0,#0]
00001c  f0410108          ORR      r1,r1,#8
000020  6001              STR      r1,[r0,#0]
;;;411    
;;;412    
;;;413        SysTick->LOAD = 300000 * CyclesPerUs;
000022  4808              LDR      r0,|L33.68|
000024  6801              LDR      r1,[r0,#0]  ; CyclesPerUs
000026  4808              LDR      r0,|L33.72|
000028  4341              MULS     r1,r0,r1
00002a  f04f20e0          MOV      r0,#0xe000e000
00002e  6141              STR      r1,[r0,#0x14]
;;;414        SysTick->VAL   = (0x00);
000030  2100              MOVS     r1,#0
000032  6181              STR      r1,[r0,#0x18]
;;;415        SysTick->CTRL = SysTick->CTRL | SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk;
000034  6901              LDR      r1,[r0,#0x10]
000036  f0410105          ORR      r1,r1,#5
00003a  6101              STR      r1,[r0,#0x10]
;;;416    //	SysTick_Config(300 * CyclesPerUs);
;;;417    
;;;418    
;;;419    }
00003c  4770              BX       lr
;;;420    
                          ENDP

00003e  0000              DCW      0x0000
                  |L33.64|
                          DCD      0x4000c000
                  |L33.68|
                          DCD      CyclesPerUs
                  |L33.72|
                          DCD      0x000493e0

                          AREA ||i.set_IAP_boot_mode||, CODE, READONLY, ALIGN=2

                  set_IAP_boot_mode PROC
;;;304    
;;;305    int set_IAP_boot_mode(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;306    {
;;;307        uint32_t  au32Config[2];
;;;308    
;;;309        if (FMC_ReadConfig(au32Config, 2) < 0)
000002  2102              MOVS     r1,#2
000004  4668              MOV      r0,sp
000006  f7fffffe          BL       FMC_ReadConfig
00000a  2800              CMP      r0,#0
00000c  da05              BGE      |L34.26|
;;;310        {
;;;311            printf("\nboot loader : Read User Config failed!\n");
00000e  a00d              ADR      r0,|L34.68|
000010  f7fffffe          BL       __2printf
;;;312            return -1;
000014  f04f30ff          MOV      r0,#0xffffffff
;;;313        }
;;;314    
;;;315        /*
;;;316            CONFIG0[7:6]
;;;317            00 = Boot from LDROM with IAP mode.
;;;318            01 = Boot from LDROM without IAP mode.
;;;319            10 = Boot from APROM with IAP mode.
;;;320            11 = Boot from APROM without IAP mode.
;;;321        */
;;;322        if (au32Config[0] & 0x40)      /* Boot from APROM with IAP mode */
;;;323        {
;;;324            FMC_ENABLE_CFG_UPDATE();
;;;325            au32Config[0] &= ~0x40;
;;;326            FMC_WriteConfig(au32Config, 2);
;;;327    
;;;328            // Perform chip reset to make new User Config take effect
;;;329            SYS->IPRST0 = SYS_IPRST0_CHIPRST_Msk;
;;;330        }
;;;331        return 0;
;;;332    }
000018  bd1c              POP      {r2-r4,pc}
                  |L34.26|
00001a  9800              LDR      r0,[sp,#0]            ;322
00001c  0640              LSLS     r0,r0,#25             ;322
00001e  d50f              BPL      |L34.64|
000020  4813              LDR      r0,|L34.112|
000022  6801              LDR      r1,[r0,#0]            ;324
000024  f0410110          ORR      r1,r1,#0x10           ;324
000028  6001              STR      r1,[r0,#0]            ;324
00002a  9800              LDR      r0,[sp,#0]            ;325
00002c  2102              MOVS     r1,#2                 ;326
00002e  f0200040          BIC      r0,r0,#0x40           ;325
000032  9000              STR      r0,[sp,#0]            ;326
000034  4668              MOV      r0,sp                 ;326
000036  f7fffffe          BL       FMC_WriteConfig
00003a  2001              MOVS     r0,#1                 ;329
00003c  0781              LSLS     r1,r0,#30             ;329
00003e  6088              STR      r0,[r1,#8]            ;329
                  |L34.64|
000040  2000              MOVS     r0,#0                 ;331
000042  bd1c              POP      {r2-r4,pc}
;;;333    
                          ENDP

                  |L34.68|
000044  0a626f6f          DCB      "\nboot loader : Read User Config failed!\n",0
000048  74206c6f
00004c  61646572
000050  203a2052
000054  65616420
000058  55736572
00005c  20436f6e
000060  66696720
000064  6661696c
000068  6564210a
00006c  00      
00006d  00                DCB      0
00006e  00                DCB      0
00006f  00                DCB      0
                  |L34.112|
                          DCD      0x4000c000

                          AREA ||i.set_tick||, CODE, READONLY, ALIGN=2

                  set_tick PROC
;;;40     
;;;41     void set_tick(uint32_t t)
000000  4901              LDR      r1,|L35.8|
;;;42     {
;;;43     	counter_tick = t;
000002  6048              STR      r0,[r1,#4]  ; counter_tick
;;;44     }
000004  4770              BX       lr
;;;45     
                          ENDP

000006  0000              DCW      0x0000
                  |L35.8|
                          DCD      ||.data||

                          AREA ||i.tick_counter||, CODE, READONLY, ALIGN=2

                  tick_counter PROC
;;;30     
;;;31     void tick_counter(void)
000000  4802              LDR      r0,|L36.12|
;;;32     {
;;;33     	counter_tick++;
000002  6841              LDR      r1,[r0,#4]  ; counter_tick
000004  1c49              ADDS     r1,r1,#1
000006  6041              STR      r1,[r0,#4]  ; counter_tick
;;;34     }
000008  4770              BX       lr
;;;35     
                          ENDP

00000a  0000              DCW      0x0000
                  |L36.12|
                          DCD      ||.data||

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  __FUNCTION__
000000  52656164          DCB      0x52,0x65,0x61,0x64
000004  5f425300          DCB      0x5f,0x42,0x53,0x00
                  |symbol_number.107|
000008  636f6d70          DCB      0x63,0x6f,0x6d,0x70
00000c  6172655f          DCB      0x61,0x72,0x65,0x5f
000010  62756666          DCB      0x62,0x75,0x66,0x66
000014  657200            DCB      0x65,0x72,0x00
                  |symbol_number.108|
000017  6c                DCB      0x6c
000018  6f61645f          DCB      0x6f,0x61,0x64,0x5f
00001c  696d6167          DCB      0x69,0x6d,0x61,0x67
000020  655f746f          DCB      0x65,0x5f,0x74,0x6f
000024  5f666c61          DCB      0x5f,0x66,0x6c,0x61
000028  736800            DCB      0x73,0x68,0x00
                  |symbol_number.109|
00002b  4a                DCB      0x4a
00002c  756d705f          DCB      0x75,0x6d,0x70,0x5f
000030  546f5f41          DCB      0x54,0x6f,0x5f,0x41
000034  70706c69          DCB      0x70,0x70,0x6c,0x69
000038  63617469          DCB      0x63,0x61,0x74,0x69
00003c  6f6e00            DCB      0x6f,0x6e,0x00
                  |symbol_number.110|
00003f  43                DCB      0x43
000040  6865636b          DCB      0x68,0x65,0x63,0x6b
000044  5f69665f          DCB      0x5f,0x69,0x66,0x5f
000048  46575f75          DCB      0x46,0x57,0x5f,0x75
00004c  70646174          DCB      0x70,0x64,0x61,0x74
000050  655f5469          DCB      0x65,0x5f,0x54,0x69
000054  6d654f75          DCB      0x6d,0x65,0x4f,0x75
000058  7400              DCB      0x74,0x00
                  |symbol_number.111|
00005a  544d              DCB      0x54,0x4d
00005c  52315f49          DCB      0x52,0x31,0x5f,0x49
000060  52514861          DCB      0x52,0x51,0x48,0x61
000064  6e646c65          DCB      0x6e,0x64,0x6c,0x65
000068  7200              DCB      0x72,0x00

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  626f6f74          DCB      "boot loader >>>>> APP_01 in KEIL linker option R/O base"
000004  206c6f61
000008  64657220
00000c  3e3e3e3e
000010  3e204150
000014  505f3031
000018  20696e20
00001c  4b45494c
000020  206c696e
000024  6b657220
000028  6f707469
00002c  6f6e2052
000030  2f4f2062
000034  617365  
000037  203a3078          DCB      " :0x00008000\r\n",0
00003b  30303030
00003f  38303030
000043  0d0a00  
000046  00                DCB      0
000047  00                DCB      0
000048  626f6f74          DCB      "boot loader >>>>> APP_02 in KEIL linker option R/O base"
00004c  206c6f61
000050  64657220
000054  3e3e3e3e
000058  3e204150
00005c  505f3032
000060  20696e20
000064  4b45494c
000068  206c696e
00006c  6b657220
000070  6f707469
000074  6f6e2052
000078  2f4f2062
00007c  617365  
00007f  203a3078          DCB      " :0x00008000\r\n",0
000083  30303030
000087  38303030
00008b  0d0a00  
00008e  00                DCB      0
00008f  00                DCB      0
000090  626f6f74          DCB      "boot loader : Company ID ............................ ["
000094  206c6f61
000098  64657220
00009c  3a20436f
0000a0  6d70616e
0000a4  79204944
0000a8  202e2e2e
0000ac  2e2e2e2e
0000b0  2e2e2e2e
0000b4  2e2e2e2e
0000b8  2e2e2e2e
0000bc  2e2e2e2e
0000c0  2e2e2e2e
0000c4  2e205b  
0000c7  30782530          DCB      "0x%08X]\r\n",0
0000cb  38585d0d
0000cf  0a00    
0000d1  00                DCB      0
0000d2  00                DCB      0
0000d3  00                DCB      0
0000d4  626f6f74          DCB      "boot loader : Product ID ............................ ["
0000d8  206c6f61
0000dc  64657220
0000e0  3a205072
0000e4  6f647563
0000e8  74204944
0000ec  202e2e2e
0000f0  2e2e2e2e
0000f4  2e2e2e2e
0000f8  2e2e2e2e
0000fc  2e2e2e2e
000100  2e2e2e2e
000104  2e2e2e2e
000108  2e205b  
00010b  30782530          DCB      "0x%08X]\r\n",0
00010f  38585d0d
000113  0a00    
000115  00                DCB      0
000116  00                DCB      0
000117  00                DCB      0
000118  626f6f74          DCB      "boot loader : User Config 0 ......................... ["
00011c  206c6f61
000120  64657220
000124  3a205573
000128  65722043
00012c  6f6e6669
000130  67203020
000134  2e2e2e2e
000138  2e2e2e2e
00013c  2e2e2e2e
000140  2e2e2e2e
000144  2e2e2e2e
000148  2e2e2e2e
00014c  2e205b  
00014f  30782530          DCB      "0x%08X]\r\n",0
000153  38585d0d
000157  0a00    
000159  00                DCB      0
00015a  00                DCB      0
00015b  00                DCB      0
00015c  626f6f74          DCB      "boot loader : User Config 1 ......................... ["
000160  206c6f61
000164  64657220
000168  3a205573
00016c  65722043
000170  6f6e6669
000174  67203120
000178  2e2e2e2e
00017c  2e2e2e2e
000180  2e2e2e2e
000184  2e2e2e2e
000188  2e2e2e2e
00018c  2e2e2e2e
000190  2e205b  
000193  30782530          DCB      "0x%08X]\r\n",0
000197  38585d0d
00019b  0a00    
00019d  00                DCB      0
00019e  00                DCB      0
00019f  00                DCB      0
0001a0  626f6f74          DCB      "boot loader : selection option to manual update firmwar"
0001a4  206c6f61
0001a8  64657220
0001ac  3a207365
0001b0  6c656374
0001b4  696f6e20
0001b8  6f707469
0001bc  6f6e2074
0001c0  6f206d61
0001c4  6e75616c
0001c8  20757064
0001cc  61746520
0001d0  6669726d
0001d4  776172  
0001d7  65206f72          DCB      "e or jump to application.\r\n",0
0001db  206a756d
0001df  7020746f
0001e3  20617070
0001e7  6c696361
0001eb  74696f6e
0001ef  2e0d0a00
0001f3  00                DCB      0
0001f4  626f6f74          DCB      "boot loader : [1] , update APP_01 to 0x8000 ,  (APP_01 "
0001f8  206c6f61
0001fc  64657220
000200  3a205b31
000204  5d202c20
000208  75706461
00020c  74652041
000210  50505f30
000214  3120746f
000218  20307838
00021c  30303020
000220  2c202028
000224  4150505f
000228  303120  
00022b  73746f72          DCB      "store in 0x10000)\r\n",0
00022f  6520696e
000233  20307831
000237  30303030
00023b  290d0a00
00023f  00                DCB      0
000240  626f6f74          DCB      "boot loader : [2] , update APP_02 to 0x8000 , (APP_02 s"
000244  206c6f61
000248  64657220
00024c  3a205b32
000250  5d202c20
000254  75706461
000258  74652041
00025c  50505f30
000260  3220746f
000264  20307838
000268  30303020
00026c  2c202841
000270  50505f30
000274  322073  
000277  746f7265          DCB      "tore in 0x12000)\r\n",0
00027b  20696e20
00027f  30783132
000283  30303029
000287  0d0a00  

                          AREA ||.data||, DATA, ALIGN=2

                  BitFlag
                          DCD      0x00000000
                  counter_tick
                          DCD      0x00000000
                  LOG
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_BitFlag____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_main_c_BitFlag____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_BitFlag____REVSH|
#line 402
|__asm___6_main_c_BitFlag____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_BitFlag____RRX|
#line 587
|__asm___6_main_c_BitFlag____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
