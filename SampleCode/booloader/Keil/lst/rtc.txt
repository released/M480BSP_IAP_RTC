; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\rtc.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\rtc.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\Library\StdDriver\inc -I..\..\Template -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\rtc.crf ..\..\..\Library\StdDriver\src\rtc.c]
                          THUMB

                          AREA ||i.RTC_32KCalibration||, CODE, READONLY, ALIGN=2

                  RTC_32KCalibration PROC
;;;109      */
;;;110    void RTC_32KCalibration(int32_t i32FrequencyX10000)
000000  b570              PUSH     {r4-r6,lr}
;;;111    {
;;;112        uint64_t u64Compensate;
;;;113        int32_t i32RegInt,i32RegFra ;
;;;114    
;;;115        if(!(SYS->CSERVER & 0x1))
000002  f04f4180          MOV      r1,#0x40000000
000006  f8d111f4          LDR      r1,[r1,#0x1f4]
;;;116        {
;;;117            u64Compensate = (uint64_t)(0x2710000000000);
;;;118            u64Compensate = (uint64_t)(u64Compensate / (uint64_t)i32FrequencyX10000);
;;;119    
;;;120            if(u64Compensate >= (uint64_t)0x400000)
;;;121            {
;;;122                u64Compensate = (uint64_t)0x3FFFFF;
;;;123            }
;;;124    
;;;125            RTC_WaitAccessEnable();
;;;126            RTC->FREQADJ = (uint32_t)u64Compensate;
00000a  4e1b              LDR      r6,|L1.120|
00000c  07c9              LSLS     r1,r1,#31             ;115
00000e  d017              BEQ      |L1.64|
;;;127        }
;;;128        else
;;;129        {
;;;130            /* Compute Integer and Fraction for RTC register*/
;;;131            i32RegInt = (i32FrequencyX10000/10000) - 32752;
000010  f2427110          MOV      r1,#0x2710
000014  fb90f4f1          SDIV     r4,r0,r1
;;;132            i32RegFra = ((((i32FrequencyX10000%10000)) * 64) + 5000) / 10000;
000018  fb90f2f1          SDIV     r2,r0,r1
00001c  fb010012          MLS      r0,r1,r2,r0
000020  104a              ASRS     r2,r1,#1
000022  eb021080          ADD      r0,r2,r0,LSL #6
000026  fb90f5f1          SDIV     r5,r0,r1
00002a  f5a444fe          SUB      r4,r4,#0x7f00
00002e  3cf0              SUBS     r4,r4,#0xf0
;;;133    
;;;134            if(i32RegFra >= 0x40)
000030  2d40              CMP      r5,#0x40
000032  db01              BLT      |L1.56|
;;;135            {
;;;136                i32RegFra = 0x0;
000034  2500              MOVS     r5,#0
000036  1c64              ADDS     r4,r4,#1
                  |L1.56|
;;;137                i32RegInt++;
;;;138            }
;;;139    
;;;140            /* Judge Integer part is reasonable */
;;;141            if ( (i32RegInt < 0) | (i32RegInt > 31) )
000038  2c1f              CMP      r4,#0x1f
00003a  dd13              BLE      |L1.100|
00003c  2001              MOVS     r0,#1
00003e  e012              B        |L1.102|
                  |L1.64|
000040  4602              MOV      r2,r0
000042  17c3              ASRS     r3,r0,#31             ;118
000044  2000              MOVS     r0,#0                 ;118
000046  490d              LDR      r1,|L1.124|
000048  f7fffffe          BL       __aeabi_uldivmod
00004c  4604              MOV      r4,r0                 ;118
00004e  f44f0280          MOV      r2,#0x400000          ;120
000052  1a80              SUBS     r0,r0,r2              ;120
000054  f1710000          SBCS     r0,r1,#0              ;120
000058  d300              BCC      |L1.92|
00005a  1e54              SUBS     r4,r2,#1              ;120
                  |L1.92|
00005c  f7fffffe          BL       RTC_WaitAccessEnable
000060  60b4              STR      r4,[r6,#8]            ;126
                  |L1.98|
;;;142            {
;;;143                return;
;;;144            }
;;;145    
;;;146            RTC_WaitAccessEnable();
;;;147            RTC->FREQADJ = (uint32_t)((i32RegInt<<8) | i32RegFra);
;;;148        }
;;;149    
;;;150    }
000062  bd70              POP      {r4-r6,pc}
                  |L1.100|
000064  2000              MOVS     r0,#0                 ;141
                  |L1.102|
000066  ea5070d4          ORRS     r0,r0,r4,LSR #31      ;141
00006a  d1fa              BNE      |L1.98|
00006c  f7fffffe          BL       RTC_WaitAccessEnable
000070  ea452004          ORR      r0,r5,r4,LSL #8       ;147
000074  60b0              STR      r0,[r6,#8]            ;147
000076  bd70              POP      {r4-r6,pc}
;;;151    
                          ENDP

                  |L1.120|
                          DCD      0x40041000
                  |L1.124|
                          DCD      0x00027100

                          AREA ||i.RTC_Close||, CODE, READONLY, ALIGN=1

                  RTC_Close PROC
;;;96       */
;;;97     void RTC_Close(void)
000000  f04f4080          MOV      r0,#0x40000000
;;;98     {
;;;99         CLK->APBCLK0 &= ~CLK_APBCLK0_RTCCKEN_Msk;
000004  f8d01208          LDR      r1,[r0,#0x208]
000008  f0210102          BIC      r1,r1,#2
00000c  f8c01208          STR      r1,[r0,#0x208]
;;;100    }
000010  4770              BX       lr
;;;101    
                          ENDP


                          AREA ||i.RTC_DisableInt||, CODE, READONLY, ALIGN=2

                  RTC_DisableInt PROC
;;;791      */
;;;792    void RTC_DisableInt(uint32_t u32IntFlagMask)
000000  b570              PUSH     {r4-r6,lr}
;;;793    {
000002  4605              MOV      r5,r0
;;;794        RTC_WaitAccessEnable();
000004  f7fffffe          BL       RTC_WaitAccessEnable
;;;795        RTC->INTEN  &= ~u32IntFlagMask;
000008  4c03              LDR      r4,|L3.24|
00000a  6aa0              LDR      r0,[r4,#0x28]
00000c  43a8              BICS     r0,r0,r5
00000e  62a0              STR      r0,[r4,#0x28]
;;;796        RTC_WaitAccessEnable();
000010  f7fffffe          BL       RTC_WaitAccessEnable
;;;797        RTC->INTSTS = u32IntFlagMask;
000014  62e5              STR      r5,[r4,#0x2c]
;;;798    }
000016  bd70              POP      {r4-r6,pc}
;;;799    
                          ENDP

                  |L3.24|
                          DCD      0x40041000

                          AREA ||i.RTC_DisableSpareRegister||, CODE, READONLY, ALIGN=2

                  RTC_DisableSpareRegister PROC
;;;824      */
;;;825    void RTC_DisableSpareRegister(void)
000000  b510              PUSH     {r4,lr}
;;;826    {
;;;827        RTC_WaitAccessEnable();
000002  f7fffffe          BL       RTC_WaitAccessEnable
;;;828    
;;;829        RTC->SPRCTL &= ~RTC_SPRCTL_SPRRWEN_Msk;
000006  4803              LDR      r0,|L4.20|
000008  6bc1              LDR      r1,[r0,#0x3c]
00000a  f0210104          BIC      r1,r1,#4
00000e  63c1              STR      r1,[r0,#0x3c]
;;;830    }
000010  bd10              POP      {r4,pc}
;;;831    
                          ENDP

000012  0000              DCW      0x0000
                  |L4.20|
                          DCD      0x40041000

                          AREA ||i.RTC_DynamicTamperConfig||, CODE, READONLY, ALIGN=2

                  RTC_DynamicTamperConfig PROC
;;;1071     */
;;;1072   void RTC_DynamicTamperConfig(uint32_t u32ChangeRate, uint32_t u32SeedReload, uint32_t u32RefPattern, uint32_t u32Seed)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1073   {
000004  4698              MOV      r8,r3
000006  4615              MOV      r5,r2
000008  460e              MOV      r6,r1
00000a  4607              MOV      r7,r0
;;;1074       uint32_t u32Reg;
;;;1075       RTC_WaitAccessEnable();
00000c  f7fffffe          BL       RTC_WaitAccessEnable
;;;1076       u32Reg = RTC->TAMPCTL;
000010  4c0c              LDR      r4,|L5.68|
000012  f8d40120          LDR      r0,[r4,#0x120]
;;;1077   
;;;1078       u32Reg &= ~(RTC_TAMPCTL_DYNSRC_Msk | RTC_TAMPCTL_SEEDRLD_Msk | RTC_TAMPCTL_DYNRATE_Msk);
;;;1079   
;;;1080       u32Reg |= (u32ChangeRate) | ((u32SeedReload & 0x1ul) << RTC_TAMPCTL_SEEDRLD_Pos) |
000016  f0060101          AND      r1,r6,#1
00001a  ea471101          ORR      r1,r7,r1,LSL #4
00001e  f0050203          AND      r2,r5,#3
000022  f02000fc          BIC      r0,r0,#0xfc           ;1078
000026  ea410582          ORR      r5,r1,r2,LSL #2
00002a  4305              ORRS     r5,r5,r0
00002c  f5047490          ADD      r4,r4,#0x120
;;;1081                 ((u32RefPattern & 0x3ul) << RTC_TAMPCTL_DYNSRC_Pos);
;;;1082   
;;;1083       RTC_WaitAccessEnable();
000030  f7fffffe          BL       RTC_WaitAccessEnable
;;;1084       RTC->TAMPSEED = u32Seed; /* need set seed value before re-load seed */
000034  f8c48008          STR      r8,[r4,#8]
;;;1085       RTC_WaitAccessEnable();
000038  f7fffffe          BL       RTC_WaitAccessEnable
;;;1086       RTC->TAMPCTL = u32Reg;
00003c  6025              STR      r5,[r4,#0]
;;;1087   }
00003e  e8bd81f0          POP      {r4-r8,pc}
;;;1088   
                          ENDP

000042  0000              DCW      0x0000
                  |L5.68|
                          DCD      0x40041000

                          AREA ||i.RTC_DynamicTamperDisable||, CODE, READONLY, ALIGN=2

                  RTC_DynamicTamperDisable PROC
;;;1007     */
;;;1008   void RTC_DynamicTamperDisable(uint32_t u32PairSel)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1009   {
;;;1010       uint32_t i;
;;;1011       uint32_t u32Reg;
;;;1012       uint32_t u32TmpReg;
;;;1013       uint32_t u32Tamper2En = 0ul, u32Tamper4En = 0ul;
000004  2500              MOVS     r5,#0
000006  4604              MOV      r4,r0                 ;1009
000008  462e              MOV      r6,r5
;;;1014   
;;;1015       RTC_WaitAccessEnable();
00000a  f7fffffe          BL       RTC_WaitAccessEnable
;;;1016       u32Reg = RTC->TAMPCTL;
00000e  4f13              LDR      r7,|L6.92|
000010  f8d71120          LDR      r1,[r7,#0x120]
;;;1017   
;;;1018       if((u32Reg & RTC_TAMPCTL_DYN1ISS_Msk) && (u32PairSel & RTC_PAIR1_SELECT))
000014  07c8              LSLS     r0,r1,#31
000016  d003              BEQ      |L6.32|
000018  07a0              LSLS     r0,r4,#30
00001a  d501              BPL      |L6.32|
;;;1019       {
;;;1020           u32Tamper2En = u32Reg & RTC_TAMPCTL_TAMP2EN_Msk;
00001c  f4013580          AND      r5,r1,#0x10000
                  |L6.32|
;;;1021       }
;;;1022   
;;;1023       if((u32Reg & RTC_TAMPCTL_DYN2ISS_Msk) && (u32PairSel & RTC_PAIR2_SELECT))
000020  0788              LSLS     r0,r1,#30
000022  d503              BPL      |L6.44|
000024  0760              LSLS     r0,r4,#29
000026  d501              BPL      |L6.44|
;;;1024       {
;;;1025           u32Tamper4En = u32Reg & RTC_TAMPCTL_TAMP4EN_Msk;
000028  f0017680          AND      r6,r1,#0x1000000
                  |L6.44|
;;;1026       }
;;;1027   
;;;1028       u32TmpReg = (RTC_TAMPCTL_TAMP0EN_Msk | RTC_TAMPCTL_TAMP1EN_Msk | RTC_TAMPCTL_DYNPR0EN_Msk);
00002c  f44f4311          MOV      r3,#0x9100
;;;1029   
;;;1030       for(i = 0ul; i < MAX_PAIR_NUM; i++)
000030  2000              MOVS     r0,#0
;;;1031       {
;;;1032           if(u32PairSel & (0x1ul << i))
000032  f04f0c01          MOV      r12,#1
                  |L6.54|
000036  fa0cf200          LSL      r2,r12,r0
00003a  4222              TST      r2,r4
00003c  d003              BEQ      |L6.70|
;;;1033           {
;;;1034               u32Reg &= ~(u32TmpReg << ((i*8ul)));
00003e  00c2              LSLS     r2,r0,#3
000040  fa03f202          LSL      r2,r3,r2
000044  4391              BICS     r1,r1,r2
                  |L6.70|
000046  1c40              ADDS     r0,r0,#1
000048  2803              CMP      r0,#3                 ;1030
00004a  d3f4              BCC      |L6.54|
;;;1035           }
;;;1036       }
;;;1037   
;;;1038       u32Reg |= (u32Tamper2En | u32Tamper4En);
00004c  4335              ORRS     r5,r5,r6
00004e  430d              ORRS     r5,r5,r1
;;;1039   
;;;1040       RTC_WaitAccessEnable();
000050  f7fffffe          BL       RTC_WaitAccessEnable
;;;1041       RTC->TAMPCTL = u32Reg;
000054  f8c75120          STR      r5,[r7,#0x120]
;;;1042   }
000058  e8bd81f0          POP      {r4-r8,pc}
;;;1043   
                          ENDP

                  |L6.92|
                          DCD      0x40041000

                          AREA ||i.RTC_DynamicTamperEnable||, CODE, READONLY, ALIGN=2

                  RTC_DynamicTamperEnable PROC
;;;942      */
;;;943    void RTC_DynamicTamperEnable(uint32_t u32PairSel, uint32_t u32DebounceEn, uint32_t u32Pair1Source, uint32_t u32Pair2Source)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;944    {
000004  461f              MOV      r7,r3
000006  4616              MOV      r6,r2
000008  468a              MOV      r10,r1
00000a  4605              MOV      r5,r0
;;;945        uint32_t i;
;;;946        uint32_t u32Reg;
;;;947        uint32_t u32TmpReg;
;;;948        uint32_t u32Tamper2Debounce, u32Tamper4Debounce;
;;;949    
;;;950        RTC_WaitAccessEnable();
00000c  f7fffffe          BL       RTC_WaitAccessEnable
;;;951        u32Reg = RTC->TAMPCTL;
000010  f8df9080          LDR      r9,|L7.148|
000014  f8d90120          LDR      r0,[r9,#0x120]
;;;952    
;;;953        u32Tamper2Debounce = u32Reg & RTC_TAMPCTL_TAMP2DBEN_Msk;
;;;954        u32Tamper4Debounce = u32Reg & RTC_TAMPCTL_TAMP4DBEN_Msk;
;;;955    
;;;956        u32Reg &= ~(RTC_TAMPCTL_TAMP0EN_Msk | RTC_TAMPCTL_TAMP1EN_Msk | RTC_TAMPCTL_TAMP2EN_Msk |
000018  491f              LDR      r1,|L7.152|
00001a  f4002880          AND      r8,r0,#0x40000        ;953
00001e  f0006c80          AND      r12,r0,#0x4000000     ;954
000022  4008              ANDS     r0,r0,r1
;;;957                    RTC_TAMPCTL_TAMP3EN_Msk | RTC_TAMPCTL_TAMP4EN_Msk | RTC_TAMPCTL_TAMP5EN_Msk);
;;;958        u32Reg &= ~(RTC_TAMPCTL_DYN1ISS_Msk | RTC_TAMPCTL_DYN2ISS_Msk);
;;;959        u32Reg |= ((u32Pair1Source & 0x1ul) << RTC_TAMPCTL_DYN1ISS_Pos) | ((u32Pair2Source & 0x1ul) << RTC_TAMPCTL_DYN2ISS_Pos);
000024  f0070101          AND      r1,r7,#1
000028  4634              MOV      r4,r6
00002a  f0200003          BIC      r0,r0,#3              ;958
00002e  f361045f          BFI      r4,r1,#1,#31
000032  4304              ORRS     r4,r4,r0
;;;960    
;;;961        if(u32DebounceEn)
000034  f1ba0f00          CMP      r10,#0
000038  d002              BEQ      |L7.64|
;;;962        {
;;;963            u32TmpReg = (RTC_TAMPCTL_TAMP0EN_Msk | RTC_TAMPCTL_TAMP1EN_Msk |
00003a  f44f4255          MOV      r2,#0xd500
00003e  e001              B        |L7.68|
                  |L7.64|
;;;964                         RTC_TAMPCTL_TAMP0DBEN_Msk | RTC_TAMPCTL_TAMP1DBEN_Msk | RTC_TAMPCTL_DYNPR0EN_Msk);
;;;965        }
;;;966        else
;;;967        {
;;;968            u32TmpReg = (RTC_TAMPCTL_TAMP0EN_Msk | RTC_TAMPCTL_TAMP1EN_Msk | RTC_TAMPCTL_DYNPR0EN_Msk);
000040  f44f4211          MOV      r2,#0x9100
                  |L7.68|
;;;969        }
;;;970    
;;;971        for(i = 0ul; i < MAX_PAIR_NUM; i++)
000044  2000              MOVS     r0,#0
;;;972        {
;;;973            if(u32PairSel & (0x1ul << i))
000046  f04f0a01          MOV      r10,#1
;;;974            {
;;;975                u32Reg &= ~((RTC_TAMPCTL_TAMP0DBEN_Msk | RTC_TAMPCTL_TAMP1DBEN_Msk) << (i*8ul));
00004a  f44f4b88          MOV      r11,#0x4400
                  |L7.78|
00004e  fa0af100          LSL      r1,r10,r0             ;973
000052  4229              TST      r1,r5                 ;973
000054  d006              BEQ      |L7.100|
000056  00c1              LSLS     r1,r0,#3
000058  fa0bf301          LSL      r3,r11,r1
00005c  439c              BICS     r4,r4,r3
;;;976                u32Reg |= (u32TmpReg << (i*8ul));
00005e  fa02f301          LSL      r3,r2,r1
000062  431c              ORRS     r4,r4,r3
                  |L7.100|
000064  1c40              ADDS     r0,r0,#1
000066  2803              CMP      r0,#3                 ;971
000068  d3f1              BCC      |L7.78|
;;;977            }
;;;978        }
;;;979    
;;;980        if((u32Pair1Source) && (u32PairSel & RTC_PAIR1_SELECT))
00006a  b12e              CBZ      r6,|L7.120|
00006c  07a8              LSLS     r0,r5,#30
00006e  d503              BPL      |L7.120|
;;;981        {
;;;982            u32Reg &= ~RTC_TAMPCTL_TAMP2EN_Msk;
000070  f4243480          BIC      r4,r4,#0x10000
;;;983            u32Reg |= u32Tamper2Debounce;
000074  ea440408          ORR      r4,r4,r8
                  |L7.120|
;;;984        }
;;;985    
;;;986        if((u32Pair2Source) && (u32PairSel & RTC_PAIR2_SELECT))
000078  b12f              CBZ      r7,|L7.134|
00007a  0768              LSLS     r0,r5,#29
00007c  d503              BPL      |L7.134|
;;;987        {
;;;988            u32Reg &= ~RTC_TAMPCTL_TAMP4EN_Msk;
00007e  f0247480          BIC      r4,r4,#0x1000000
;;;989            u32Reg |= u32Tamper4Debounce;
000082  ea44040c          ORR      r4,r4,r12
                  |L7.134|
;;;990        }
;;;991    
;;;992        RTC_WaitAccessEnable();
000086  f7fffffe          BL       RTC_WaitAccessEnable
;;;993        RTC->TAMPCTL = u32Reg;
00008a  f8c94120          STR      r4,[r9,#0x120]
;;;994    }
00008e  e8bd9ff0          POP      {r4-r12,pc}
;;;995    
                          ENDP

000092  0000              DCW      0x0000
                  |L7.148|
                          DCD      0x40041000
                  |L7.152|
                          DCD      0xeeeeeeff

                          AREA ||i.RTC_EnableInt||, CODE, READONLY, ALIGN=2

                  RTC_EnableInt PROC
;;;768      */
;;;769    void RTC_EnableInt(uint32_t u32IntFlagMask)
000000  b510              PUSH     {r4,lr}
;;;770    {
000002  4604              MOV      r4,r0
;;;771        RTC_WaitAccessEnable();
000004  f7fffffe          BL       RTC_WaitAccessEnable
;;;772        RTC->INTEN |= u32IntFlagMask;
000008  4902              LDR      r1,|L8.20|
00000a  6a8a              LDR      r2,[r1,#0x28]
00000c  4322              ORRS     r2,r2,r4
00000e  628a              STR      r2,[r1,#0x28]
;;;773    }
000010  bd10              POP      {r4,pc}
;;;774    
                          ENDP

000012  0000              DCW      0x0000
                  |L8.20|
                          DCD      0x40041000

                          AREA ||i.RTC_EnableSpareAccess||, CODE, READONLY, ALIGN=2

                  RTC_EnableSpareAccess PROC
;;;808      */
;;;809    void RTC_EnableSpareAccess(void)
000000  b510              PUSH     {r4,lr}
;;;810    {
;;;811        RTC_WaitAccessEnable();
000002  f7fffffe          BL       RTC_WaitAccessEnable
;;;812    
;;;813        RTC->SPRCTL |= RTC_SPRCTL_SPRRWEN_Msk;
000006  4803              LDR      r0,|L9.20|
000008  6bc1              LDR      r1,[r0,#0x3c]
00000a  f0410104          ORR      r1,r1,#4
00000e  63c1              STR      r1,[r0,#0x3c]
;;;814    }
000010  bd10              POP      {r4,pc}
;;;815    
                          ENDP

000012  0000              DCW      0x0000
                  |L9.20|
                          DCD      0x40041000

                          AREA ||i.RTC_GetAlarmDateAndTime||, CODE, READONLY, ALIGN=2

                  RTC_GetAlarmDateAndTime PROC
;;;264      */
;;;265    void RTC_GetAlarmDateAndTime(S_RTC_TIME_DATA_T *sPt)
000000  b570              PUSH     {r4-r6,lr}
;;;266    {
;;;267        uint32_t u32Tmp;
;;;268    
;;;269        sPt->u32TimeScale = RTC->CLKFMT & RTC_CLKFMT_24HEN_Msk;     /* 12/24-hour */
000002  4e3c              LDR      r6,|L10.244|
000004  4604              MOV      r4,r0                 ;266
000006  6970              LDR      r0,[r6,#0x14]
000008  f0000001          AND      r0,r0,#1
;;;270        sPt->u32DayOfWeek = RTC->WEEKDAY & RTC_WEEKDAY_WEEKDAY_Msk; /* Day of the week */
00000c  61e0              STR      r0,[r4,#0x1c]
00000e  69b0              LDR      r0,[r6,#0x18]
000010  f0000007          AND      r0,r0,#7
;;;271    
;;;272        /* Get alarm [Date digit] data */
;;;273        RTC_WaitAccessEnable();
000014  60e0              STR      r0,[r4,#0xc]
000016  f7fffffe          BL       RTC_WaitAccessEnable
;;;274        g_u32hiYear  = (RTC->CALM & RTC_CALM_TENYEAR_Msk) >> RTC_CALM_TENYEAR_Pos;
00001a  6a30              LDR      r0,[r6,#0x20]
00001c  4d36              LDR      r5,|L10.248|
00001e  f3c05003          UBFX     r0,r0,#20,#4
000022  6028              STR      r0,[r5,#0]  ; g_u32hiYear
;;;275        g_u32loYear  = (RTC->CALM & RTC_CALM_YEAR_Msk) >> RTC_CALM_YEAR_Pos;
000024  6a30              LDR      r0,[r6,#0x20]
000026  f3c04003          UBFX     r0,r0,#16,#4
00002a  6068              STR      r0,[r5,#4]  ; g_u32loYear
;;;276        g_u32hiMonth = (RTC->CALM & RTC_CALM_TENMON_Msk) >> RTC_CALM_TENMON_Pos;
00002c  6a30              LDR      r0,[r6,#0x20]
00002e  f3c03000          UBFX     r0,r0,#12,#1
000032  60a8              STR      r0,[r5,#8]  ; g_u32hiMonth
;;;277        g_u32loMonth = (RTC->CALM & RTC_CALM_MON_Msk) >> RTC_CALM_MON_Pos;
000034  6a30              LDR      r0,[r6,#0x20]
000036  f3c02003          UBFX     r0,r0,#8,#4
00003a  60e8              STR      r0,[r5,#0xc]  ; g_u32loMonth
;;;278        g_u32hiDay   = (RTC->CALM & RTC_CALM_TENDAY_Msk) >> RTC_CALM_TENDAY_Pos;
00003c  6a30              LDR      r0,[r6,#0x20]
00003e  f3c01001          UBFX     r0,r0,#4,#2
000042  6128              STR      r0,[r5,#0x10]  ; g_u32hiDay
;;;279        g_u32loDay   = (RTC->CALM & RTC_CALM_DAY_Msk) >> RTC_CALM_DAY_Pos;
000044  6a30              LDR      r0,[r6,#0x20]
000046  f000000f          AND      r0,r0,#0xf
00004a  6168              STR      r0,[r5,#0x14]  ; g_u32loDay
;;;280    
;;;281        /* Get alarm [Time digit] data */
;;;282        RTC_WaitAccessEnable();
00004c  f7fffffe          BL       RTC_WaitAccessEnable
;;;283        g_u32hiHour = (RTC->TALM & RTC_TALM_TENHR_Msk) >> RTC_TALM_TENHR_Pos;
000050  69f0              LDR      r0,[r6,#0x1c]
000052  f3c05001          UBFX     r0,r0,#20,#2
000056  61a8              STR      r0,[r5,#0x18]  ; g_u32hiHour
;;;284        g_u32loHour = (RTC->TALM & RTC_TALM_HR_Msk) >> RTC_TALM_HR_Pos;
000058  69f0              LDR      r0,[r6,#0x1c]
00005a  f3c04003          UBFX     r0,r0,#16,#4
00005e  61e8              STR      r0,[r5,#0x1c]  ; g_u32loHour
;;;285        g_u32hiMin  = (RTC->TALM & RTC_TALM_TENMIN_Msk) >> RTC_TALM_TENMIN_Pos;
000060  69f0              LDR      r0,[r6,#0x1c]
000062  f3c03002          UBFX     r0,r0,#12,#3
000066  6228              STR      r0,[r5,#0x20]  ; g_u32hiMin
;;;286        g_u32loMin  = (RTC->TALM & RTC_TALM_MIN_Msk) >> RTC_TALM_MIN_Pos;
000068  69f0              LDR      r0,[r6,#0x1c]
00006a  f3c02003          UBFX     r0,r0,#8,#4
00006e  6268              STR      r0,[r5,#0x24]  ; g_u32loMin
;;;287        g_u32hiSec  = (RTC->TALM & RTC_TALM_TENSEC_Msk) >> RTC_TALM_TENSEC_Pos;
000070  69f0              LDR      r0,[r6,#0x1c]
000072  f3c01002          UBFX     r0,r0,#4,#3
000076  62a8              STR      r0,[r5,#0x28]  ; g_u32hiSec
;;;288        g_u32loSec  = (RTC->TALM & RTC_TALM_SEC_Msk) >> RTC_TALM_SEC_Pos;
000078  69f0              LDR      r0,[r6,#0x1c]
00007a  f000000f          AND      r0,r0,#0xf
00007e  62e8              STR      r0,[r5,#0x2c]  ; g_u32loSec
;;;289    
;;;290        /* Compute to 20XX year */
;;;291        u32Tmp  = (g_u32hiYear * 10ul);
000080  6828              LDR      r0,[r5,#0]  ; g_u32hiYear
;;;292        u32Tmp += g_u32loYear;
000082  6869              LDR      r1,[r5,#4]  ; g_u32loYear
000084  eb000080          ADD      r0,r0,r0,LSL #2       ;291
000088  eb010040          ADD      r0,r1,r0,LSL #1
00008c  f50060fa          ADD      r0,r0,#0x7d0
;;;293        sPt->u32Year = u32Tmp + RTC_YEAR2000;
;;;294    
;;;295        /* Compute 0~12 month */
;;;296        u32Tmp = (g_u32hiMonth * 10ul);
000090  6020              STR      r0,[r4,#0]
000092  68a8              LDR      r0,[r5,#8]  ; g_u32hiMonth
;;;297        sPt->u32Month = u32Tmp + g_u32loMonth;
000094  68e9              LDR      r1,[r5,#0xc]  ; g_u32loMonth
000096  eb000080          ADD      r0,r0,r0,LSL #2       ;296
00009a  eb010040          ADD      r0,r1,r0,LSL #1
;;;298    
;;;299        /* Compute 0~31 day */
;;;300        u32Tmp = (g_u32hiDay * 10ul);
00009e  6060              STR      r0,[r4,#4]
0000a0  6928              LDR      r0,[r5,#0x10]  ; g_u32hiDay
;;;301        sPt->u32Day = u32Tmp + g_u32loDay;
0000a2  6969              LDR      r1,[r5,#0x14]  ; g_u32loDay
0000a4  eb000080          ADD      r0,r0,r0,LSL #2       ;300
0000a8  eb010040          ADD      r0,r1,r0,LSL #1
;;;302    
;;;303        /* Compute 12/24 hour */
;;;304        if(sPt->u32TimeScale == RTC_CLOCK_12)
0000ac  60a0              STR      r0,[r4,#8]
0000ae  69e0              LDR      r0,[r4,#0x1c]
0000b0  2800              CMP      r0,#0
;;;305        {
;;;306            u32Tmp  = (g_u32hiHour * 10ul);
;;;307            u32Tmp += g_u32loHour;
;;;308            sPt->u32Hour = u32Tmp;          /* AM: 1~12. PM: 21~32. */
;;;309    
;;;310            if(sPt->u32Hour >= 21ul)
;;;311            {
;;;312                sPt->u32AmPm  = RTC_PM;
;;;313                sPt->u32Hour -= 20ul;
;;;314            }
;;;315            else
;;;316            {
;;;317                sPt->u32AmPm = RTC_AM;
;;;318            }
;;;319    
;;;320            u32Tmp  = (g_u32hiMin * 10ul);
;;;321            u32Tmp += g_u32loMin;
;;;322            sPt->u32Minute = u32Tmp;
;;;323    
;;;324            u32Tmp  = (g_u32hiSec * 10ul);
;;;325            u32Tmp += g_u32loSec;
;;;326            sPt->u32Second = u32Tmp;
;;;327    
;;;328        }
;;;329        else
;;;330        {
;;;331            u32Tmp  = (g_u32hiHour * 10ul);
0000b2  69a8              LDR      r0,[r5,#0x18]  ; g_u32hiHour
;;;332            u32Tmp +=  g_u32loHour;
0000b4  69e9              LDR      r1,[r5,#0x1c]  ; g_u32loHour
0000b6  eb000080          ADD      r0,r0,r0,LSL #2       ;331
0000ba  ea4f0040          LSL      r0,r0,#1              ;331
0000be  4408              ADD      r0,r0,r1
0000c0  d105              BNE      |L10.206|
0000c2  6120              STR      r0,[r4,#0x10]         ;310
0000c4  2815              CMP      r0,#0x15              ;310
0000c6  d304              BCC      |L10.210|
0000c8  2102              MOVS     r1,#2                 ;312
0000ca  3814              SUBS     r0,r0,#0x14           ;312
0000cc  6221              STR      r1,[r4,#0x20]         ;312
                  |L10.206|
;;;333            sPt->u32Hour = u32Tmp;
0000ce  6120              STR      r0,[r4,#0x10]
0000d0  e001              B        |L10.214|
                  |L10.210|
0000d2  2001              MOVS     r0,#1                 ;317
0000d4  6220              STR      r0,[r4,#0x20]         ;317
                  |L10.214|
0000d6  6a28              LDR      r0,[r5,#0x20]         ;320  ; g_u32hiMin
0000d8  6a69              LDR      r1,[r5,#0x24]         ;321  ; g_u32loMin
0000da  eb000080          ADD      r0,r0,r0,LSL #2       ;320
0000de  eb010040          ADD      r0,r1,r0,LSL #1       ;321
0000e2  6160              STR      r0,[r4,#0x14]         ;324
0000e4  6aa8              LDR      r0,[r5,#0x28]         ;324  ; g_u32hiSec
0000e6  6ae9              LDR      r1,[r5,#0x2c]         ;325  ; g_u32loSec
0000e8  eb000080          ADD      r0,r0,r0,LSL #2       ;324
0000ec  eb010040          ADD      r0,r1,r0,LSL #1       ;325
0000f0  61a0              STR      r0,[r4,#0x18]         ;326
;;;334    
;;;335            u32Tmp  = (g_u32hiMin * 10ul);
;;;336            u32Tmp += g_u32loMin;
;;;337            sPt->u32Minute = u32Tmp;
;;;338    
;;;339            u32Tmp  = (g_u32hiSec * 10ul);
;;;340            u32Tmp += g_u32loSec;
;;;341            sPt->u32Second = u32Tmp;
;;;342        }
;;;343    }
0000f2  bd70              POP      {r4-r6,pc}
;;;344    
                          ENDP

                  |L10.244|
                          DCD      0x40041000
                  |L10.248|
                          DCD      ||.data||

                          AREA ||i.RTC_GetDateAndTime||, CODE, READONLY, ALIGN=2

                  RTC_GetDateAndTime PROC
;;;169      */
;;;170    void RTC_GetDateAndTime(S_RTC_TIME_DATA_T *sPt)
000000  4a38              LDR      r2,|L11.228|
;;;171    {
000002  b510              PUSH     {r4,lr}
;;;172        uint32_t u32Tmp;
;;;173    
;;;174        sPt->u32TimeScale = RTC->CLKFMT & RTC_CLKFMT_24HEN_Msk;     /* 12/24-hour */
000004  6951              LDR      r1,[r2,#0x14]
000006  f0110301          ANDS     r3,r1,#1
;;;175        sPt->u32DayOfWeek = RTC->WEEKDAY & RTC_WEEKDAY_WEEKDAY_Msk; /* Day of the week */
00000a  61c3              STR      r3,[r0,#0x1c]
00000c  6991              LDR      r1,[r2,#0x18]
00000e  f0010107          AND      r1,r1,#7
;;;176    
;;;177        /* Get [Date digit] data */
;;;178        g_u32hiYear  = (RTC->CAL & RTC_CAL_TENYEAR_Msk) >> RTC_CAL_TENYEAR_Pos;
000012  60c1              STR      r1,[r0,#0xc]
000014  6911              LDR      r1,[r2,#0x10]
000016  f3c15403          UBFX     r4,r1,#20,#4
00001a  4933              LDR      r1,|L11.232|
00001c  600c              STR      r4,[r1,#0]  ; g_u32hiYear
;;;179        g_u32loYear  = (RTC->CAL & RTC_CAL_YEAR_Msk) >> RTC_CAL_YEAR_Pos;
00001e  6914              LDR      r4,[r2,#0x10]
000020  f3c44403          UBFX     r4,r4,#16,#4
000024  604c              STR      r4,[r1,#4]  ; g_u32loYear
;;;180        g_u32hiMonth = (RTC->CAL & RTC_CAL_TENMON_Msk) >> RTC_CAL_TENMON_Pos;
000026  6914              LDR      r4,[r2,#0x10]
000028  f3c43400          UBFX     r4,r4,#12,#1
00002c  608c              STR      r4,[r1,#8]  ; g_u32hiMonth
;;;181        g_u32loMonth = (RTC->CAL & RTC_CAL_MON_Msk) >> RTC_CAL_MON_Pos;
00002e  6914              LDR      r4,[r2,#0x10]
000030  f3c42403          UBFX     r4,r4,#8,#4
000034  60cc              STR      r4,[r1,#0xc]  ; g_u32loMonth
;;;182        g_u32hiDay   = (RTC->CAL & RTC_CAL_TENDAY_Msk) >> RTC_CAL_TENDAY_Pos;
000036  6914              LDR      r4,[r2,#0x10]
000038  f3c41401          UBFX     r4,r4,#4,#2
00003c  610c              STR      r4,[r1,#0x10]  ; g_u32hiDay
;;;183        g_u32loDay   = (RTC->CAL & RTC_CAL_DAY_Msk) >> RTC_CAL_DAY_Pos;
00003e  6914              LDR      r4,[r2,#0x10]
000040  f004040f          AND      r4,r4,#0xf
000044  614c              STR      r4,[r1,#0x14]  ; g_u32loDay
;;;184    
;;;185        /* Get [Time digit] data */
;;;186        g_u32hiHour = (RTC->TIME & RTC_TIME_TENHR_Msk) >> RTC_TIME_TENHR_Pos;
000046  68d4              LDR      r4,[r2,#0xc]
000048  f3c45401          UBFX     r4,r4,#20,#2
00004c  618c              STR      r4,[r1,#0x18]  ; g_u32hiHour
;;;187        g_u32loHour = (RTC->TIME & RTC_TIME_HR_Msk) >> RTC_TIME_HR_Pos;
00004e  68d4              LDR      r4,[r2,#0xc]
000050  f3c44403          UBFX     r4,r4,#16,#4
000054  61cc              STR      r4,[r1,#0x1c]  ; g_u32loHour
;;;188        g_u32hiMin  = (RTC->TIME & RTC_TIME_TENMIN_Msk) >> RTC_TIME_TENMIN_Pos;
000056  68d4              LDR      r4,[r2,#0xc]
000058  f3c43402          UBFX     r4,r4,#12,#3
00005c  620c              STR      r4,[r1,#0x20]  ; g_u32hiMin
;;;189        g_u32loMin  = (RTC->TIME & RTC_TIME_MIN_Msk) >> RTC_TIME_MIN_Pos;
00005e  68d4              LDR      r4,[r2,#0xc]
000060  f3c42403          UBFX     r4,r4,#8,#4
000064  624c              STR      r4,[r1,#0x24]  ; g_u32loMin
;;;190        g_u32hiSec  = (RTC->TIME & RTC_TIME_TENSEC_Msk) >> RTC_TIME_TENSEC_Pos;
000066  68d4              LDR      r4,[r2,#0xc]
000068  f3c41402          UBFX     r4,r4,#4,#3
00006c  628c              STR      r4,[r1,#0x28]  ; g_u32hiSec
;;;191        g_u32loSec  = (RTC->TIME & RTC_TIME_SEC_Msk) >> RTC_TIME_SEC_Pos;
00006e  68d2              LDR      r2,[r2,#0xc]
000070  f002020f          AND      r2,r2,#0xf
000074  62ca              STR      r2,[r1,#0x2c]  ; g_u32loSec
;;;192    
;;;193        /* Compute to 20XX year */
;;;194        u32Tmp  = (g_u32hiYear * 10ul);
000076  680a              LDR      r2,[r1,#0]  ; g_u32hiYear
;;;195        u32Tmp += g_u32loYear;
000078  684c              LDR      r4,[r1,#4]  ; g_u32loYear
00007a  eb020282          ADD      r2,r2,r2,LSL #2       ;194
00007e  eb040242          ADD      r2,r4,r2,LSL #1
000082  f50262fa          ADD      r2,r2,#0x7d0
;;;196        sPt->u32Year = u32Tmp + RTC_YEAR2000;
;;;197    
;;;198        /* Compute 0~12 month */
;;;199        u32Tmp = (g_u32hiMonth * 10ul);
000086  6002              STR      r2,[r0,#0]
000088  688a              LDR      r2,[r1,#8]  ; g_u32hiMonth
;;;200        sPt->u32Month = u32Tmp + g_u32loMonth;
00008a  68cc              LDR      r4,[r1,#0xc]  ; g_u32loMonth
00008c  eb020282          ADD      r2,r2,r2,LSL #2       ;199
000090  eb040242          ADD      r2,r4,r2,LSL #1
;;;201    
;;;202        /* Compute 0~31 day */
;;;203        u32Tmp = (g_u32hiDay * 10ul);
000094  6042              STR      r2,[r0,#4]
000096  690a              LDR      r2,[r1,#0x10]  ; g_u32hiDay
;;;204        sPt->u32Day =  u32Tmp  + g_u32loDay;
000098  694c              LDR      r4,[r1,#0x14]  ; g_u32loDay
00009a  eb020282          ADD      r2,r2,r2,LSL #2       ;203
00009e  eb040242          ADD      r2,r4,r2,LSL #1
;;;205    
;;;206        /* Compute 12/24 hour */
;;;207        if(sPt->u32TimeScale == RTC_CLOCK_12)
;;;208        {
;;;209            u32Tmp = (g_u32hiHour * 10ul);
;;;210            u32Tmp += g_u32loHour;
;;;211            sPt->u32Hour = u32Tmp;          /* AM: 1~12. PM: 21~32. */
;;;212    
;;;213            if(sPt->u32Hour >= 21ul)
;;;214            {
;;;215                sPt->u32AmPm  = RTC_PM;
;;;216                sPt->u32Hour -= 20ul;
;;;217            }
;;;218            else
;;;219            {
;;;220                sPt->u32AmPm = RTC_AM;
;;;221            }
;;;222    
;;;223            u32Tmp  = (g_u32hiMin  * 10ul);
;;;224            u32Tmp += g_u32loMin;
;;;225            sPt->u32Minute = u32Tmp;
;;;226    
;;;227            u32Tmp  = (g_u32hiSec  * 10ul);
;;;228            u32Tmp += g_u32loSec;
;;;229            sPt->u32Second = u32Tmp;
;;;230        }
;;;231        else
;;;232        {
;;;233            u32Tmp  = (g_u32hiHour * 10ul);
0000a2  6082              STR      r2,[r0,#8]
0000a4  698a              LDR      r2,[r1,#0x18]  ; g_u32hiHour
;;;234            u32Tmp += g_u32loHour;
0000a6  69cb              LDR      r3,[r1,#0x1c]  ; g_u32loHour
0000a8  eb020282          ADD      r2,r2,r2,LSL #2       ;233
0000ac  eb030242          ADD      r2,r3,r2,LSL #1
0000b0  d105              BNE      |L11.190|
0000b2  6102              STR      r2,[r0,#0x10]         ;213
0000b4  2a15              CMP      r2,#0x15              ;213
0000b6  d304              BCC      |L11.194|
0000b8  2302              MOVS     r3,#2                 ;215
0000ba  3a14              SUBS     r2,r2,#0x14           ;215
0000bc  6203              STR      r3,[r0,#0x20]         ;215
                  |L11.190|
;;;235            sPt->u32Hour = u32Tmp;
0000be  6102              STR      r2,[r0,#0x10]
0000c0  e001              B        |L11.198|
                  |L11.194|
0000c2  2201              MOVS     r2,#1                 ;220
0000c4  6202              STR      r2,[r0,#0x20]         ;220
                  |L11.198|
0000c6  6a0a              LDR      r2,[r1,#0x20]         ;223  ; g_u32hiMin
0000c8  6a4b              LDR      r3,[r1,#0x24]         ;224  ; g_u32loMin
0000ca  eb020282          ADD      r2,r2,r2,LSL #2       ;223
0000ce  eb030242          ADD      r2,r3,r2,LSL #1       ;224
0000d2  6142              STR      r2,[r0,#0x14]         ;227
0000d4  6a8a              LDR      r2,[r1,#0x28]         ;227  ; g_u32hiSec
0000d6  6ac9              LDR      r1,[r1,#0x2c]         ;228  ; g_u32loSec
0000d8  eb020282          ADD      r2,r2,r2,LSL #2       ;227
0000dc  eb010142          ADD      r1,r1,r2,LSL #1       ;228
0000e0  6181              STR      r1,[r0,#0x18]         ;229
;;;236    
;;;237            u32Tmp  = (g_u32hiMin * 10ul);
;;;238            u32Tmp +=  g_u32loMin;
;;;239            sPt->u32Minute = u32Tmp;
;;;240    
;;;241            u32Tmp  = (g_u32hiSec * 10ul);
;;;242            u32Tmp += g_u32loSec;
;;;243            sPt->u32Second = u32Tmp;
;;;244        }
;;;245    }
0000e2  bd10              POP      {r4,pc}
;;;246    
                          ENDP

                  |L11.228|
                          DCD      0x40041000
                  |L11.232|
                          DCD      ||.data||

                          AREA ||i.RTC_GetDayOfWeek||, CODE, READONLY, ALIGN=2

                  RTC_GetDayOfWeek PROC
;;;721      */
;;;722    uint32_t RTC_GetDayOfWeek(void)
000000  4802              LDR      r0,|L12.12|
;;;723    {
;;;724        return (RTC->WEEKDAY & RTC_WEEKDAY_WEEKDAY_Msk);
000002  6980              LDR      r0,[r0,#0x18]
000004  f0000007          AND      r0,r0,#7
;;;725    }
000008  4770              BX       lr
;;;726    
                          ENDP

00000a  0000              DCW      0x0000
                  |L12.12|
                          DCD      0x40041000

                          AREA ||i.RTC_Open||, CODE, READONLY, ALIGN=2

                  RTC_Open PROC
;;;65       */
;;;66     void RTC_Open(S_RTC_TIME_DATA_T *sPt)
000000  4908              LDR      r1,|L13.36|
;;;67     {
;;;68         RTC->INIT = RTC_INIT_KEY;
000002  4a07              LDR      r2,|L13.32|
000004  600a              STR      r2,[r1,#0]
;;;69     
;;;70         if(RTC->INIT != RTC_INIT_ACTIVE_Msk)
000006  680b              LDR      r3,[r1,#0]
000008  2b01              CMP      r3,#1
00000a  d003              BEQ      |L13.20|
;;;71         {
;;;72             RTC->INIT = RTC_INIT_KEY;
00000c  600a              STR      r2,[r1,#0]
                  |L13.14|
;;;73             while(RTC->INIT != RTC_INIT_ACTIVE_Msk)
00000e  680a              LDR      r2,[r1,#0]
000010  2a01              CMP      r2,#1
000012  d1fc              BNE      |L13.14|
                  |L13.20|
;;;74             {
;;;75             }
;;;76         }
;;;77     
;;;78         if(sPt == 0)
000014  2800              CMP      r0,#0
000016  d001              BEQ      |L13.28|
;;;79         {
;;;80         }
;;;81         else
;;;82         {
;;;83             /* Set RTC date and time */
;;;84             RTC_SetDateAndTime(sPt);
000018  f7ffbffe          B.W      RTC_SetDateAndTime
                  |L13.28|
;;;85         }
;;;86     }
00001c  4770              BX       lr
;;;87     
                          ENDP

00001e  0000              DCW      0x0000
                  |L13.32|
                          DCD      0xa5eb1357
                  |L13.36|
                          DCD      0x40041000

                          AREA ||i.RTC_SetAlarmDate||, CODE, READONLY, ALIGN=2

                  RTC_SetAlarmDate PROC
;;;591      */
;;;592    void RTC_SetAlarmDate(uint32_t u32Year, uint32_t u32Month, uint32_t u32Day)
000000  b570              PUSH     {r4-r6,lr}
;;;593    {
;;;594        uint32_t u32RegCALM;
;;;595    
;;;596        u32RegCALM  = ((u32Year - RTC_YEAR2000) / 10ul) << 20;
000002  230a              MOVS     r3,#0xa
000004  f5a060fa          SUB      r0,r0,#0x7d0
000008  fbb0f4f3          UDIV     r4,r0,r3
;;;597        u32RegCALM |= (((u32Year - RTC_YEAR2000) % 10ul) << 16);
00000c  fbb0f5f3          UDIV     r5,r0,r3
000010  fb030015          MLS      r0,r3,r5,r0
000014  0524              LSLS     r4,r4,#20             ;596
000016  ea444000          ORR      r0,r4,r0,LSL #16
;;;598        u32RegCALM |= ((u32Month / 10ul) << 12);
00001a  fbb1f4f3          UDIV     r4,r1,r3
00001e  ea403004          ORR      r0,r0,r4,LSL #12
;;;599        u32RegCALM |= ((u32Month % 10ul) << 8);
000022  fbb1f4f3          UDIV     r4,r1,r3
000026  fb031114          MLS      r1,r3,r4,r1
00002a  ea402001          ORR      r0,r0,r1,LSL #8
;;;600        u32RegCALM |= ((u32Day   / 10ul) << 4);
00002e  fbb2f1f3          UDIV     r1,r2,r3
000032  ea401001          ORR      r0,r0,r1,LSL #4
;;;601        u32RegCALM |= (u32Day   % 10ul);
000036  fbb2f1f3          UDIV     r1,r2,r3
00003a  fb032411          MLS      r4,r3,r1,r2
00003e  4304              ORRS     r4,r4,r0
;;;602    
;;;603        RTC_WaitAccessEnable();
000040  f7fffffe          BL       RTC_WaitAccessEnable
;;;604    
;;;605        /* Set RTC Alarm Date */
;;;606        RTC->CALM = (uint32_t)u32RegCALM;
000044  4801              LDR      r0,|L14.76|
000046  6204              STR      r4,[r0,#0x20]
;;;607    }
000048  bd70              POP      {r4-r6,pc}
;;;608    
                          ENDP

00004a  0000              DCW      0x0000
                  |L14.76|
                          DCD      0x40041000

                          AREA ||i.RTC_SetAlarmDateAndTime||, CODE, READONLY, ALIGN=2

                  RTC_SetAlarmDateAndTime PROC
;;;445      */
;;;446    void RTC_SetAlarmDateAndTime(S_RTC_TIME_DATA_T *sPt)
000000  b570              PUSH     {r4-r6,lr}
;;;447    {
000002  0004              MOVS     r4,r0
000004  d050              BEQ      |L15.168|
;;;448        uint32_t u32RegCALM, u32RegTALM;
;;;449    
;;;450        if(sPt == 0)
;;;451        {
;;;452        }
;;;453        else
;;;454        {
;;;455            /*-----------------------------------------------------------------------------------------------------*/
;;;456            /* Set RTC 24/12 hour setting and Day of the Week                                                      */
;;;457            /*-----------------------------------------------------------------------------------------------------*/
;;;458            RTC_WaitAccessEnable();
000006  f7fffffe          BL       RTC_WaitAccessEnable
;;;459            if(sPt->u32TimeScale == RTC_CLOCK_12)
;;;460            {
;;;461                RTC->CLKFMT &= ~RTC_CLKFMT_24HEN_Msk;
00000a  4d2d              LDR      r5,|L15.192|
00000c  69e0              LDR      r0,[r4,#0x1c]         ;459
00000e  2800              CMP      r0,#0                 ;459
;;;462    
;;;463                /*-------------------------------------------------------------------------------------------------*/
;;;464                /* Important, range of 12-hour PM mode is 21 up to 32                                               */
;;;465                /*-------------------------------------------------------------------------------------------------*/
;;;466                if(sPt->u32AmPm == RTC_PM)
;;;467                {
;;;468                    sPt->u32Hour += 20ul;
;;;469                }
;;;470            }
;;;471            else
;;;472            {
;;;473                RTC->CLKFMT |= RTC_CLKFMT_24HEN_Msk;
000010  6968              LDR      r0,[r5,#0x14]
000012  d04a              BEQ      |L15.170|
000014  f0400001          ORR      r0,r0,#1
000018  6168              STR      r0,[r5,#0x14]
                  |L15.26|
;;;474            }
;;;475    
;;;476            /*-----------------------------------------------------------------------------------------------------*/
;;;477            /* Set RTC Alarm Date and Time                                                                         */
;;;478            /*-----------------------------------------------------------------------------------------------------*/
;;;479            u32RegCALM  = ((sPt->u32Year - RTC_YEAR2000) / 10ul) << 20;
00001a  6821              LDR      r1,[r4,#0]
00001c  200a              MOVS     r0,#0xa
00001e  f5a161fa          SUB      r1,r1,#0x7d0
000022  fbb1f2f0          UDIV     r2,r1,r0
;;;480            u32RegCALM |= (((sPt->u32Year - RTC_YEAR2000) % 10ul) << 16);
000026  fbb1f3f0          UDIV     r3,r1,r0
00002a  fb001113          MLS      r1,r0,r3,r1
00002e  0512              LSLS     r2,r2,#20             ;479
000030  ea424201          ORR      r2,r2,r1,LSL #16
;;;481            u32RegCALM |= ((sPt->u32Month  / 10ul) << 12);
000034  6861              LDR      r1,[r4,#4]
000036  fbb1f3f0          UDIV     r3,r1,r0
00003a  ea423203          ORR      r2,r2,r3,LSL #12
;;;482            u32RegCALM |= ((sPt->u32Month  % 10ul) << 8);
00003e  fbb1f3f0          UDIV     r3,r1,r0
000042  fb001113          MLS      r1,r0,r3,r1
000046  ea422201          ORR      r2,r2,r1,LSL #8
;;;483            u32RegCALM |= ((sPt->u32Day    / 10ul) << 4);
00004a  68a1              LDR      r1,[r4,#8]
00004c  fbb1f3f0          UDIV     r3,r1,r0
000050  ea421203          ORR      r2,r2,r3,LSL #4
;;;484            u32RegCALM |= (sPt->u32Day    % 10ul);
000054  fbb1f3f0          UDIV     r3,r1,r0
000058  fb001613          MLS      r6,r0,r3,r1
;;;485    
;;;486            u32RegTALM  = ((sPt->u32Hour   / 10ul) << 20);
00005c  6921              LDR      r1,[r4,#0x10]
00005e  4316              ORRS     r6,r6,r2              ;484
000060  fbb1f2f0          UDIV     r2,r1,r0
;;;487            u32RegTALM |= ((sPt->u32Hour   % 10ul) << 16);
000064  fbb1f3f0          UDIV     r3,r1,r0
000068  fb001113          MLS      r1,r0,r3,r1
00006c  0512              LSLS     r2,r2,#20             ;486
00006e  ea424201          ORR      r2,r2,r1,LSL #16
;;;488            u32RegTALM |= ((sPt->u32Minute / 10ul) << 12);
000072  6961              LDR      r1,[r4,#0x14]
000074  fbb1f3f0          UDIV     r3,r1,r0
000078  ea423203          ORR      r2,r2,r3,LSL #12
;;;489            u32RegTALM |= ((sPt->u32Minute % 10ul) << 8);
00007c  fbb1f3f0          UDIV     r3,r1,r0
000080  fb001113          MLS      r1,r0,r3,r1
000084  ea422201          ORR      r2,r2,r1,LSL #8
;;;490            u32RegTALM |= ((sPt->u32Second / 10ul) << 4);
000088  69a1              LDR      r1,[r4,#0x18]
00008a  fbb1f3f0          UDIV     r3,r1,r0
00008e  ea421203          ORR      r2,r2,r3,LSL #4
;;;491            u32RegTALM |= (sPt->u32Second % 10ul);
000092  fbb1f3f0          UDIV     r3,r1,r0
000096  fb001413          MLS      r4,r0,r3,r1
00009a  4314              ORRS     r4,r4,r2
;;;492    
;;;493            RTC_WaitAccessEnable();
00009c  f7fffffe          BL       RTC_WaitAccessEnable
;;;494            RTC->CALM = (uint32_t)u32RegCALM;
0000a0  622e              STR      r6,[r5,#0x20]
;;;495            RTC_WaitAccessEnable();
0000a2  f7fffffe          BL       RTC_WaitAccessEnable
;;;496            RTC->TALM = (uint32_t)u32RegTALM;
0000a6  61ec              STR      r4,[r5,#0x1c]
                  |L15.168|
;;;497        }
;;;498    }
0000a8  bd70              POP      {r4-r6,pc}
                  |L15.170|
0000aa  f0200001          BIC      r0,r0,#1              ;461
0000ae  6168              STR      r0,[r5,#0x14]         ;461
0000b0  6a20              LDR      r0,[r4,#0x20]         ;466
0000b2  2802              CMP      r0,#2                 ;466
0000b4  d1b1              BNE      |L15.26|
0000b6  6920              LDR      r0,[r4,#0x10]         ;468
0000b8  3014              ADDS     r0,r0,#0x14           ;468
0000ba  6120              STR      r0,[r4,#0x10]         ;468
0000bc  e7ad              B        |L15.26|
;;;499    
                          ENDP

0000be  0000              DCW      0x0000
                  |L15.192|
                          DCD      0x40041000

                          AREA ||i.RTC_SetAlarmDateMask||, CODE, READONLY, ALIGN=2

                  RTC_SetAlarmDateMask PROC
;;;670      */
;;;671    void RTC_SetAlarmDateMask(uint8_t u8IsTenYMsk, uint8_t u8IsYMsk, uint8_t u8IsTenMMsk, uint8_t u8IsMMsk, uint8_t u8IsTenDMsk, uint8_t u8IsDMsk)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;672    {
000004  461f              MOV      r7,r3
000006  e9dd8908          LDRD     r8,r9,[sp,#0x20]
00000a  4616              MOV      r6,r2
00000c  460d              MOV      r5,r1
00000e  4604              MOV      r4,r0
;;;673        RTC_WaitAccessEnable();
000010  f7fffffe          BL       RTC_WaitAccessEnable
;;;674        RTC->CAMSK = ((uint32_t)u8IsTenYMsk << RTC_CAMSK_MTENYEAR_Pos) |
000014  0160              LSLS     r0,r4,#5
000016  ea401005          ORR      r0,r0,r5,LSL #4
00001a  ea4000c6          ORR      r0,r0,r6,LSL #3
00001e  ea400187          ORR      r1,r0,r7,LSL #2
000022  ea410048          ORR      r0,r1,r8,LSL #1
000026  4903              LDR      r1,|L16.52|
000028  ea400009          ORR      r0,r0,r9
00002c  6388              STR      r0,[r1,#0x38]
;;;675                     ((uint32_t)u8IsYMsk    << RTC_CAMSK_MYEAR_Pos) |
;;;676                     ((uint32_t)u8IsTenMMsk << RTC_CAMSK_MTENMON_Pos) |
;;;677                     ((uint32_t)u8IsMMsk    << RTC_CAMSK_MMON_Pos) |
;;;678                     ((uint32_t)u8IsTenDMsk << RTC_CAMSK_MTENDAY_Pos) |
;;;679                     ((uint32_t)u8IsDMsk    << RTC_CAMSK_MDAY_Pos);
;;;680    }
00002e  e8bd87f0          POP      {r4-r10,pc}
;;;681    
                          ENDP

000032  0000              DCW      0x0000
                  |L16.52|
                          DCD      0x40041000

                          AREA ||i.RTC_SetAlarmTime||, CODE, READONLY, ALIGN=2

                  RTC_SetAlarmTime PROC
;;;621      */
;;;622    void RTC_SetAlarmTime(uint32_t u32Hour, uint32_t u32Minute, uint32_t u32Second, uint32_t u32TimeMode, uint32_t u32AmPm)
000000  b570              PUSH     {r4-r6,lr}
;;;623    {
000002  001d              MOVS     r5,r3
000004  9b04              LDR      r3,[sp,#0x10]
000006  d102              BNE      |L17.14|
;;;624        uint32_t u32RegTALM;
;;;625    
;;;626        /* Important, range of 12-hour PM mode is 21 up to 32 */
;;;627        if((u32TimeMode == RTC_CLOCK_12) && (u32AmPm == RTC_PM))
000008  2b02              CMP      r3,#2
00000a  d100              BNE      |L17.14|
00000c  3014              ADDS     r0,r0,#0x14
                  |L17.14|
;;;628        {
;;;629            u32Hour += 20ul;
;;;630        }
;;;631    
;;;632        u32RegTALM  = ((u32Hour   / 10ul) << 20);
00000e  240a              MOVS     r4,#0xa
000010  fbb0f3f4          UDIV     r3,r0,r4
;;;633        u32RegTALM |= ((u32Hour   % 10ul) << 16);
000014  fbb0f6f4          UDIV     r6,r0,r4
000018  fb040016          MLS      r0,r4,r6,r0
00001c  051b              LSLS     r3,r3,#20             ;632
00001e  ea434000          ORR      r0,r3,r0,LSL #16
;;;634        u32RegTALM |= ((u32Minute / 10ul) << 12);
000022  fbb1f3f4          UDIV     r3,r1,r4
000026  ea403003          ORR      r0,r0,r3,LSL #12
;;;635        u32RegTALM |= ((u32Minute % 10ul) << 8);
00002a  fbb1f3f4          UDIV     r3,r1,r4
00002e  fb041113          MLS      r1,r4,r3,r1
000032  ea402001          ORR      r0,r0,r1,LSL #8
;;;636        u32RegTALM |= ((u32Second / 10ul) << 4);
000036  fbb2f1f4          UDIV     r1,r2,r4
00003a  ea401001          ORR      r0,r0,r1,LSL #4
;;;637        u32RegTALM |= (u32Second % 10ul);
00003e  fbb2f1f4          UDIV     r1,r2,r4
000042  fb042611          MLS      r6,r4,r1,r2
000046  4306              ORRS     r6,r6,r0
;;;638    
;;;639        /*-----------------------------------------------------------------------------------------------------*/
;;;640        /* Set RTC 24/12 hour setting and Day of the Week                                                      */
;;;641        /*-----------------------------------------------------------------------------------------------------*/
;;;642        RTC_WaitAccessEnable();
000048  f7fffffe          BL       RTC_WaitAccessEnable
;;;643        if(u32TimeMode == RTC_CLOCK_12)
;;;644        {
;;;645            RTC->CLKFMT &= ~RTC_CLKFMT_24HEN_Msk;
00004c  4c06              LDR      r4,|L17.104|
;;;646        }
;;;647        else
;;;648        {
;;;649            RTC->CLKFMT |= RTC_CLKFMT_24HEN_Msk;
00004e  6960              LDR      r0,[r4,#0x14]
000050  b135              CBZ      r5,|L17.96|
000052  f0400001          ORR      r0,r0,#1
                  |L17.86|
000056  6160              STR      r0,[r4,#0x14]
;;;650        }
;;;651    
;;;652        /* Set RTC Alarm Time */
;;;653        RTC_WaitAccessEnable();
000058  f7fffffe          BL       RTC_WaitAccessEnable
;;;654        RTC->TALM = (uint32_t)u32RegTALM;
00005c  61e6              STR      r6,[r4,#0x1c]
;;;655    }
00005e  bd70              POP      {r4-r6,pc}
                  |L17.96|
000060  f0200001          BIC      r0,r0,#1              ;645
000064  e7f7              B        |L17.86|
;;;656    
                          ENDP

000066  0000              DCW      0x0000
                  |L17.104|
                          DCD      0x40041000

                          AREA ||i.RTC_SetAlarmTimeMask||, CODE, READONLY, ALIGN=2

                  RTC_SetAlarmTimeMask PROC
;;;695      */
;;;696    void RTC_SetAlarmTimeMask(uint8_t u8IsTenHMsk, uint8_t u8IsHMsk, uint8_t u8IsTenMMsk, uint8_t u8IsMMsk, uint8_t u8IsTenSMsk, uint8_t u8IsSMsk)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;697    {
000004  461f              MOV      r7,r3
000006  e9dd8908          LDRD     r8,r9,[sp,#0x20]
00000a  4616              MOV      r6,r2
00000c  460d              MOV      r5,r1
00000e  4604              MOV      r4,r0
;;;698        RTC_WaitAccessEnable();
000010  f7fffffe          BL       RTC_WaitAccessEnable
;;;699        RTC->TAMSK = ((uint32_t)u8IsTenHMsk << RTC_TAMSK_MTENHR_Pos) |
000014  0160              LSLS     r0,r4,#5
000016  ea401005          ORR      r0,r0,r5,LSL #4
00001a  ea4000c6          ORR      r0,r0,r6,LSL #3
00001e  ea400187          ORR      r1,r0,r7,LSL #2
000022  ea410048          ORR      r0,r1,r8,LSL #1
000026  4903              LDR      r1,|L18.52|
000028  ea400009          ORR      r0,r0,r9
00002c  6348              STR      r0,[r1,#0x34]
;;;700                     ((uint32_t)u8IsHMsk    << RTC_TAMSK_MHR_Pos) |
;;;701                     ((uint32_t)u8IsTenMMsk << RTC_TAMSK_MTENMIN_Pos) |
;;;702                     ((uint32_t)u8IsMMsk    << RTC_TAMSK_MMIN_Pos) |
;;;703                     ((uint32_t)u8IsTenSMsk << RTC_TAMSK_MTENSEC_Pos) |
;;;704                     ((uint32_t)u8IsSMsk    << RTC_TAMSK_MSEC_Pos);
;;;705    }
00002e  e8bd87f0          POP      {r4-r10,pc}
;;;706    
                          ENDP

000032  0000              DCW      0x0000
                  |L18.52|
                          DCD      0x40041000

                          AREA ||i.RTC_SetDate||, CODE, READONLY, ALIGN=2

                  RTC_SetDate PROC
;;;513      */
;;;514    void RTC_SetDate(uint32_t u32Year, uint32_t u32Month, uint32_t u32Day, uint32_t u32DayOfWeek)
000000  b570              PUSH     {r4-r6,lr}
;;;515    {
;;;516        uint32_t u32RegCAL;
;;;517    
;;;518        u32RegCAL  = ((u32Year - RTC_YEAR2000) / 10ul) << 20;
000002  240a              MOVS     r4,#0xa
000004  f5a060fa          SUB      r0,r0,#0x7d0
000008  461d              MOV      r5,r3                 ;515
00000a  fbb0f3f4          UDIV     r3,r0,r4
;;;519        u32RegCAL |= (((u32Year - RTC_YEAR2000) % 10ul) << 16);
00000e  fbb0f6f4          UDIV     r6,r0,r4
000012  fb040016          MLS      r0,r4,r6,r0
000016  051b              LSLS     r3,r3,#20             ;518
000018  ea434000          ORR      r0,r3,r0,LSL #16
;;;520        u32RegCAL |= ((u32Month / 10ul) << 12);
00001c  fbb1f3f4          UDIV     r3,r1,r4
000020  ea403003          ORR      r0,r0,r3,LSL #12
;;;521        u32RegCAL |= ((u32Month % 10ul) << 8);
000024  fbb1f3f4          UDIV     r3,r1,r4
000028  fb041113          MLS      r1,r4,r3,r1
00002c  ea402001          ORR      r0,r0,r1,LSL #8
;;;522        u32RegCAL |= ((u32Day   / 10ul) << 4);
000030  fbb2f1f4          UDIV     r1,r2,r4
000034  ea401001          ORR      r0,r0,r1,LSL #4
;;;523        u32RegCAL |= (u32Day   % 10ul);
000038  fbb2f1f4          UDIV     r1,r2,r4
00003c  fb042411          MLS      r4,r4,r1,r2
000040  4304              ORRS     r4,r4,r0
;;;524    
;;;525        /* Set Day of the Week */
;;;526        RTC_WaitAccessEnable();
000042  f7fffffe          BL       RTC_WaitAccessEnable
;;;527        RTC->WEEKDAY = u32DayOfWeek & RTC_WEEKDAY_WEEKDAY_Msk;
000046  f0050007          AND      r0,r5,#7
00004a  4d03              LDR      r5,|L19.88|
00004c  61a8              STR      r0,[r5,#0x18]
;;;528    
;;;529        /* Set RTC Calender Loading */
;;;530        RTC_WaitAccessEnable();
00004e  f7fffffe          BL       RTC_WaitAccessEnable
;;;531        RTC->CAL = (uint32_t)u32RegCAL;
000052  612c              STR      r4,[r5,#0x10]
;;;532    }
000054  bd70              POP      {r4-r6,pc}
;;;533    
                          ENDP

000056  0000              DCW      0x0000
                  |L19.88|
                          DCD      0x40041000

                          AREA ||i.RTC_SetDateAndTime||, CODE, READONLY, ALIGN=2

                  RTC_SetDateAndTime PROC
;;;364      */
;;;365    void RTC_SetDateAndTime(S_RTC_TIME_DATA_T *sPt)
000000  b570              PUSH     {r4-r6,lr}
;;;366    {
000002  0004              MOVS     r4,r0
000004  d054              BEQ      |L20.176|
;;;367        uint32_t u32RegCAL, u32RegTIME;
;;;368    
;;;369        if(sPt == 0ul)
;;;370        {
;;;371        }
;;;372        else
;;;373        {
;;;374            /*-----------------------------------------------------------------------------------------------------*/
;;;375            /* Set RTC 24/12 hour setting and Day of the Week                                                      */
;;;376            /*-----------------------------------------------------------------------------------------------------*/
;;;377            RTC_WaitAccessEnable();
000006  f7fffffe          BL       RTC_WaitAccessEnable
;;;378            if(sPt->u32TimeScale == RTC_CLOCK_12)
;;;379            {
;;;380                RTC->CLKFMT &= ~RTC_CLKFMT_24HEN_Msk;
00000a  4d2f              LDR      r5,|L20.200|
00000c  69e0              LDR      r0,[r4,#0x1c]         ;378
00000e  2800              CMP      r0,#0                 ;378
;;;381    
;;;382                /*-------------------------------------------------------------------------------------------------*/
;;;383                /* Important, range of 12-hour PM mode is 21 up to 32                                               */
;;;384                /*-------------------------------------------------------------------------------------------------*/
;;;385                if(sPt->u32AmPm == RTC_PM)
;;;386                {
;;;387                    sPt->u32Hour += 20ul;
;;;388                }
;;;389            }
;;;390            else
;;;391            {
;;;392                RTC->CLKFMT |= RTC_CLKFMT_24HEN_Msk;
000010  6968              LDR      r0,[r5,#0x14]
000012  d04e              BEQ      |L20.178|
000014  f0400001          ORR      r0,r0,#1
000018  6168              STR      r0,[r5,#0x14]
                  |L20.26|
;;;393            }
;;;394    
;;;395            /* Set Day of the Week */
;;;396            RTC_WaitAccessEnable();
00001a  f7fffffe          BL       RTC_WaitAccessEnable
;;;397            RTC->WEEKDAY = sPt->u32DayOfWeek;
00001e  68e0              LDR      r0,[r4,#0xc]
000020  61a8              STR      r0,[r5,#0x18]
;;;398    
;;;399            /*-----------------------------------------------------------------------------------------------------*/
;;;400            /* Set RTC Current Date and Time                                                                       */
;;;401            /*-----------------------------------------------------------------------------------------------------*/
;;;402            u32RegCAL  = ((sPt->u32Year - RTC_YEAR2000) / 10ul) << 20;
000022  6821              LDR      r1,[r4,#0]
000024  200a              MOVS     r0,#0xa
000026  f5a161fa          SUB      r1,r1,#0x7d0
00002a  fbb1f2f0          UDIV     r2,r1,r0
;;;403            u32RegCAL |= (((sPt->u32Year - RTC_YEAR2000) % 10ul) << 16);
00002e  fbb1f3f0          UDIV     r3,r1,r0
000032  fb001113          MLS      r1,r0,r3,r1
000036  0512              LSLS     r2,r2,#20             ;402
000038  ea424201          ORR      r2,r2,r1,LSL #16
;;;404            u32RegCAL |= ((sPt->u32Month  / 10ul) << 12);
00003c  6861              LDR      r1,[r4,#4]
00003e  fbb1f3f0          UDIV     r3,r1,r0
000042  ea423203          ORR      r2,r2,r3,LSL #12
;;;405            u32RegCAL |= ((sPt->u32Month  % 10ul) << 8);
000046  fbb1f3f0          UDIV     r3,r1,r0
00004a  fb001113          MLS      r1,r0,r3,r1
00004e  ea422201          ORR      r2,r2,r1,LSL #8
;;;406            u32RegCAL |= ((sPt->u32Day    / 10ul) << 4);
000052  68a1              LDR      r1,[r4,#8]
000054  fbb1f3f0          UDIV     r3,r1,r0
000058  ea421203          ORR      r2,r2,r3,LSL #4
;;;407            u32RegCAL |= (sPt->u32Day     % 10ul);
00005c  fbb1f3f0          UDIV     r3,r1,r0
000060  fb001613          MLS      r6,r0,r3,r1
;;;408    
;;;409            u32RegTIME  = ((sPt->u32Hour   / 10ul) << 20);
000064  6921              LDR      r1,[r4,#0x10]
000066  4316              ORRS     r6,r6,r2              ;407
000068  fbb1f2f0          UDIV     r2,r1,r0
;;;410            u32RegTIME |= ((sPt->u32Hour   % 10ul) << 16);
00006c  fbb1f3f0          UDIV     r3,r1,r0
000070  fb001113          MLS      r1,r0,r3,r1
000074  0512              LSLS     r2,r2,#20             ;409
000076  ea424201          ORR      r2,r2,r1,LSL #16
;;;411            u32RegTIME |= ((sPt->u32Minute / 10ul) << 12);
00007a  6961              LDR      r1,[r4,#0x14]
00007c  fbb1f3f0          UDIV     r3,r1,r0
000080  ea423203          ORR      r2,r2,r3,LSL #12
;;;412            u32RegTIME |= ((sPt->u32Minute % 10ul) << 8);
000084  fbb1f3f0          UDIV     r3,r1,r0
000088  fb001113          MLS      r1,r0,r3,r1
00008c  ea422201          ORR      r2,r2,r1,LSL #8
;;;413            u32RegTIME |= ((sPt->u32Second / 10ul) << 4);
000090  69a1              LDR      r1,[r4,#0x18]
000092  fbb1f3f0          UDIV     r3,r1,r0
000096  ea421203          ORR      r2,r2,r3,LSL #4
;;;414            u32RegTIME |= (sPt->u32Second % 10ul);
00009a  fbb1f3f0          UDIV     r3,r1,r0
00009e  fb001413          MLS      r4,r0,r3,r1
0000a2  4314              ORRS     r4,r4,r2
;;;415    
;;;416            /*-----------------------------------------------------------------------------------------------------*/
;;;417            /* Set RTC Calender and Time Loading                                                                   */
;;;418            /*-----------------------------------------------------------------------------------------------------*/
;;;419            RTC_WaitAccessEnable();
0000a4  f7fffffe          BL       RTC_WaitAccessEnable
;;;420            RTC->CAL  = (uint32_t)u32RegCAL;
0000a8  612e              STR      r6,[r5,#0x10]
;;;421            RTC_WaitAccessEnable();
0000aa  f7fffffe          BL       RTC_WaitAccessEnable
;;;422            RTC->TIME = (uint32_t)u32RegTIME;
0000ae  60ec              STR      r4,[r5,#0xc]
                  |L20.176|
;;;423        }
;;;424    }
0000b0  bd70              POP      {r4-r6,pc}
                  |L20.178|
0000b2  f0200001          BIC      r0,r0,#1              ;380
0000b6  6168              STR      r0,[r5,#0x14]         ;380
0000b8  6a20              LDR      r0,[r4,#0x20]         ;385
0000ba  2802              CMP      r0,#2                 ;385
0000bc  d1ad              BNE      |L20.26|
0000be  6920              LDR      r0,[r4,#0x10]         ;387
0000c0  3014              ADDS     r0,r0,#0x14           ;387
0000c2  6120              STR      r0,[r4,#0x10]         ;387
0000c4  e7a9              B        |L20.26|
;;;425    
                          ENDP

0000c6  0000              DCW      0x0000
                  |L20.200|
                          DCD      0x40041000

                          AREA ||i.RTC_SetTickPeriod||, CODE, READONLY, ALIGN=2

                  RTC_SetTickPeriod PROC
;;;744      */
;;;745    void RTC_SetTickPeriod(uint32_t u32TickSelection)
000000  b510              PUSH     {r4,lr}
;;;746    {
000002  4604              MOV      r4,r0
;;;747        RTC_WaitAccessEnable();
000004  f7fffffe          BL       RTC_WaitAccessEnable
;;;748    
;;;749        RTC->TICK = (RTC->TICK & ~RTC_TICK_TICK_Msk) | u32TickSelection;
000008  4903              LDR      r1,|L21.24|
00000a  6b08              LDR      r0,[r1,#0x30]
00000c  f0200207          BIC      r2,r0,#7
000010  4322              ORRS     r2,r2,r4
000012  630a              STR      r2,[r1,#0x30]
;;;750    }
000014  bd10              POP      {r4,pc}
;;;751    
                          ENDP

000016  0000              DCW      0x0000
                  |L21.24|
                          DCD      0x40041000

                          AREA ||i.RTC_SetTime||, CODE, READONLY, ALIGN=2

                  RTC_SetTime PROC
;;;546      */
;;;547    void RTC_SetTime(uint32_t u32Hour, uint32_t u32Minute, uint32_t u32Second, uint32_t u32TimeMode, uint32_t u32AmPm)
000000  b570              PUSH     {r4-r6,lr}
;;;548    {
000002  001d              MOVS     r5,r3
000004  9b04              LDR      r3,[sp,#0x10]
000006  d102              BNE      |L22.14|
;;;549        uint32_t u32RegTIME;
;;;550    
;;;551        /* Important, range of 12-hour PM mode is 21 up to 32 */
;;;552        if((u32TimeMode == RTC_CLOCK_12) && (u32AmPm == RTC_PM))
000008  2b02              CMP      r3,#2
00000a  d100              BNE      |L22.14|
00000c  3014              ADDS     r0,r0,#0x14
                  |L22.14|
;;;553        {
;;;554            u32Hour += 20ul;
;;;555        }
;;;556    
;;;557        u32RegTIME  = ((u32Hour   / 10ul) << 20);
00000e  240a              MOVS     r4,#0xa
000010  fbb0f3f4          UDIV     r3,r0,r4
;;;558        u32RegTIME |= ((u32Hour   % 10ul) << 16);
000014  fbb0f6f4          UDIV     r6,r0,r4
000018  fb040016          MLS      r0,r4,r6,r0
00001c  051b              LSLS     r3,r3,#20             ;557
00001e  ea434000          ORR      r0,r3,r0,LSL #16
;;;559        u32RegTIME |= ((u32Minute / 10ul) << 12);
000022  fbb1f3f4          UDIV     r3,r1,r4
000026  ea403003          ORR      r0,r0,r3,LSL #12
;;;560        u32RegTIME |= ((u32Minute % 10ul) << 8);
00002a  fbb1f3f4          UDIV     r3,r1,r4
00002e  fb041113          MLS      r1,r4,r3,r1
000032  ea402001          ORR      r0,r0,r1,LSL #8
;;;561        u32RegTIME |= ((u32Second / 10ul) << 4);
000036  fbb2f1f4          UDIV     r1,r2,r4
00003a  ea401001          ORR      r0,r0,r1,LSL #4
;;;562        u32RegTIME |= (u32Second % 10ul);
00003e  fbb2f1f4          UDIV     r1,r2,r4
000042  fb042611          MLS      r6,r4,r1,r2
000046  4306              ORRS     r6,r6,r0
;;;563    
;;;564        /*-----------------------------------------------------------------------------------------------------*/
;;;565        /* Set RTC 24/12 hour setting and Day of the Week                                                      */
;;;566        /*-----------------------------------------------------------------------------------------------------*/
;;;567        RTC_WaitAccessEnable();
000048  f7fffffe          BL       RTC_WaitAccessEnable
;;;568        if(u32TimeMode == RTC_CLOCK_12)
;;;569        {
;;;570            RTC->CLKFMT &= ~RTC_CLKFMT_24HEN_Msk;
00004c  4c06              LDR      r4,|L22.104|
;;;571        }
;;;572        else
;;;573        {
;;;574            RTC->CLKFMT |= RTC_CLKFMT_24HEN_Msk;
00004e  6960              LDR      r0,[r4,#0x14]
000050  b135              CBZ      r5,|L22.96|
000052  f0400001          ORR      r0,r0,#1
                  |L22.86|
000056  6160              STR      r0,[r4,#0x14]
;;;575        }
;;;576    
;;;577        RTC_WaitAccessEnable();
000058  f7fffffe          BL       RTC_WaitAccessEnable
;;;578        RTC->TIME = (uint32_t)u32RegTIME;
00005c  60e6              STR      r6,[r4,#0xc]
;;;579    }
00005e  bd70              POP      {r4-r6,pc}
                  |L22.96|
000060  f0200001          BIC      r0,r0,#1              ;570
000064  e7f7              B        |L22.86|
;;;580    
                          ENDP

000066  0000              DCW      0x0000
                  |L22.104|
                          DCD      0x40041000

                          AREA ||i.RTC_StaticTamperDisable||, CODE, READONLY, ALIGN=2

                  RTC_StaticTamperDisable PROC
;;;895      */
;;;896    void RTC_StaticTamperDisable(uint32_t u32TamperSelect)
000000  b570              PUSH     {r4-r6,lr}
;;;897    {
000002  4605              MOV      r5,r0
;;;898        uint32_t i;
;;;899        uint32_t u32Reg;
;;;900        uint32_t u32TmpReg;
;;;901    
;;;902        RTC_WaitAccessEnable();
000004  f7fffffe          BL       RTC_WaitAccessEnable
;;;903        u32Reg = RTC->TAMPCTL;
000008  4e0a              LDR      r6,|L23.52|
00000a  f8d64120          LDR      r4,[r6,#0x120]
;;;904    
;;;905        u32TmpReg = (RTC_TAMPCTL_TAMP0EN_Msk);
00000e  15b0              ASRS     r0,r6,#22
;;;906    
;;;907        for(i = 0ul; i < MAX_TAMPER_PIN_NUM; i++)
000010  2100              MOVS     r1,#0
;;;908        {
;;;909            if(u32TamperSelect & (0x1ul << i))
000012  2301              MOVS     r3,#1
                  |L23.20|
000014  fa03f201          LSL      r2,r3,r1
000018  422a              TST      r2,r5
00001a  d003              BEQ      |L23.36|
;;;910            {
;;;911                u32Reg &= ~(u32TmpReg << (i*4ul));
00001c  008a              LSLS     r2,r1,#2
00001e  fa00f202          LSL      r2,r0,r2
000022  4394              BICS     r4,r4,r2
                  |L23.36|
000024  1c49              ADDS     r1,r1,#1
000026  2906              CMP      r1,#6                 ;907
000028  d3f4              BCC      |L23.20|
;;;912            }
;;;913        }
;;;914    
;;;915        RTC_WaitAccessEnable();
00002a  f7fffffe          BL       RTC_WaitAccessEnable
;;;916        RTC->TAMPCTL = u32Reg;
00002e  f8c64120          STR      r4,[r6,#0x120]
;;;917    }
000032  bd70              POP      {r4-r6,pc}
;;;918    
                          ENDP

                  |L23.52|
                          DCD      0x40041000

                          AREA ||i.RTC_StaticTamperEnable||, CODE, READONLY, ALIGN=2

                  RTC_StaticTamperEnable PROC
;;;854      */
;;;855    void RTC_StaticTamperEnable(uint32_t u32TamperSelect, uint32_t u32DetecLevel, uint32_t u32DebounceEn)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;856    {
000004  4690              MOV      r8,r2
000006  460f              MOV      r7,r1
000008  4605              MOV      r5,r0
;;;857        uint32_t i;
;;;858        uint32_t u32Reg;
;;;859        uint32_t u32TmpReg;
;;;860    
;;;861        RTC_WaitAccessEnable();
00000a  f7fffffe          BL       RTC_WaitAccessEnable
;;;862        u32Reg = RTC->TAMPCTL;
00000e  4e11              LDR      r6,|L24.84|
000010  f8d64120          LDR      r4,[r6,#0x120]
;;;863    
;;;864        u32TmpReg = ( RTC_TAMPCTL_TAMP0EN_Msk | (u32DetecLevel << RTC_TAMPCTL_TAMP0LV_Pos) |
000014  0279              LSLS     r1,r7,#9
000016  ea412088          ORR      r0,r1,r8,LSL #10
;;;865                      (u32DebounceEn << RTC_TAMPCTL_TAMP0DBEN_Pos) );
;;;866    
;;;867        for(i = 0ul; i < MAX_TAMPER_PIN_NUM; i++)
00001a  2100              MOVS     r1,#0
00001c  f4407280          ORR      r2,r0,#0x100          ;864
;;;868        {
;;;869            if(u32TamperSelect & (0x1ul << i))
000020  2301              MOVS     r3,#1
;;;870            {
;;;871                u32Reg &= ~((RTC_TAMPCTL_TAMP0EN_Msk|RTC_TAMPCTL_TAMP0LV_Msk|RTC_TAMPCTL_TAMP0DBEN_Msk) << (i*4ul));
000022  f44f67e0          MOV      r7,#0x700
                  |L24.38|
000026  fa03f001          LSL      r0,r3,r1              ;869
00002a  4228              TST      r0,r5                 ;869
00002c  d008              BEQ      |L24.64|
00002e  0088              LSLS     r0,r1,#2
000030  fa07fc00          LSL      r12,r7,r0
000034  ea24040c          BIC      r4,r4,r12
;;;872                u32Reg |= (u32TmpReg << (i*4ul));
000038  fa02fc00          LSL      r12,r2,r0
00003c  ea4c0404          ORR      r4,r12,r4
                  |L24.64|
000040  1c49              ADDS     r1,r1,#1
000042  2906              CMP      r1,#6                 ;867
000044  d3ef              BCC      |L24.38|
;;;873            }
;;;874        }
;;;875    
;;;876        RTC_WaitAccessEnable();
000046  f7fffffe          BL       RTC_WaitAccessEnable
;;;877        RTC->TAMPCTL = u32Reg;
00004a  f8c64120          STR      r4,[r6,#0x120]
;;;878    
;;;879    }
00004e  e8bd81f0          POP      {r4-r8,pc}
;;;880    
                          ENDP

000052  0000              DCW      0x0000
                  |L24.84|
                          DCD      0x40041000

                          AREA ||i.RTC_WaitAccessEnable||, CODE, READONLY, ALIGN=2

                  RTC_WaitAccessEnable PROC
;;;286      */
;;;287    __STATIC_INLINE void RTC_WaitAccessEnable(void)
000000  4808              LDR      r0,|L25.36|
                  |L25.2|
;;;288    {
;;;289        while((RTC->RWEN & RTC_RWEN_RTCBUSY_Msk) == RTC_RWEN_RTCBUSY_Msk)
000002  6841              LDR      r1,[r0,#4]
000004  01c9              LSLS     r1,r1,#7
000006  d4fc              BMI      |L25.2|
;;;290        {
;;;291        }
;;;292    
;;;293        if(!(SYS->CSERVER & 0x1))
000008  f04f4180          MOV      r1,#0x40000000
00000c  f8d111f4          LDR      r1,[r1,#0x1f4]
000010  07c9              LSLS     r1,r1,#31
000012  d102              BNE      |L25.26|
;;;294        {
;;;295            /* To wait RWENF bit is cleared and enable RWENF bit (Access Enable bit) again */
;;;296            RTC->RWEN = RTC_WRITE_KEY;
000014  f64a1265          MOV      r2,#0xa965
000018  6042              STR      r2,[r0,#4]
                  |L25.26|
;;;297        }
;;;298    
;;;299        /* To wait RWENF bit is set and user can access the protected-register of RTC from now on */
;;;300        while((RTC->RWEN & RTC_RWEN_RWENF_Msk) == (uint32_t)0x0)
00001a  6841              LDR      r1,[r0,#4]
00001c  03c9              LSLS     r1,r1,#15
00001e  d5fc              BPL      |L25.26|
;;;301        {
;;;302        }
;;;303    }
000020  4770              BX       lr
;;;304    
                          ENDP

000022  0000              DCW      0x0000
                  |L25.36|
                          DCD      0x40041000

                          AREA ||.data||, DATA, ALIGN=2

                  g_u32hiYear
                          DCD      0x00000000
                  g_u32loYear
                          DCD      0x00000000
                  g_u32hiMonth
                          DCD      0x00000000
                  g_u32loMonth
                          DCD      0x00000000
                  g_u32hiDay
                          DCD      0x00000000
                  g_u32loDay
                          DCD      0x00000000
                  g_u32hiHour
                          DCD      0x00000000
                  g_u32loHour
                          DCD      0x00000000
                  g_u32hiMin
                          DCD      0x00000000
                  g_u32loMin
                          DCD      0x00000000
                  g_u32hiSec
                          DCD      0x00000000
                  g_u32loSec
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Library\\StdDriver\\src\\rtc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_rtc_c_RTC_Open____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___5_rtc_c_RTC_Open____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_rtc_c_RTC_Open____REVSH|
#line 402
|__asm___5_rtc_c_RTC_Open____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___5_rtc_c_RTC_Open____RRX|
#line 587
|__asm___5_rtc_c_RTC_Open____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
